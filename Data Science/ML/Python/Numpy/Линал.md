```python
arr = np.arange(25).reshape((5, 5))
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14],
       [15, 16, 17, 18, 19],
       [20, 21, 22, 23, 24]])
```
### Транспонирование матрицы
```python
arr.T
arr.transpose()
array([[ 0,  5, 10, 15, 20],
       [ 1,  6, 11, 16, 21],
       [ 2,  7, 12, 17, 22],
       [ 3,  8, 13, 18, 23],
       [ 4,  9, 14, 19, 24]])
```
### Перемножение
```python
np.dot(arr, arr.T)
array([[  30,   80,  130,  180,  230],
       [  80,  255,  430,  605,  780],
       [ 130,  430,  730, 1030, 1330],
       [ 180,  605, 1030, 1455, 1880],
       [ 230,  780, 1330, 1880, 2430]])
```
`np.dot` не только перемножает матрицы, но также может посимвольно умножать векторы
```python
np.dot([1, 2], [3, 4])
np.int64(11)
```
И скаляры
```python
np.dot(2, 2)
4
```
### Определитель 
```python
np.linalg.det(arr)
np.float64(0.0)
```
### Обратная матрица
```python
np.linalg.inv(arr)
```
### Главная диагональ
```python
np.diag(arr)
array([ 0,  6, 12, 18, 24])
```
Если передать параметр `k` - смещение относительно главной диагонали, можно получать "мини-диагонали". `k>0`, выше главной, `k<0`, ниже
```python
np.diag(arr, k=1)
array([ 1,  7, 13, 19])

np.diag(arr, k=-1)
array([ 5, 11, 17, 23])
```

### `triu` и `tril`
`triu` - зануляет элементы ниже главной диагонали
```python
np.triu(arr)
array([[ 0,  1,  2,  3,  4],
       [ 0,  6,  7,  8,  9],
       [ 0,  0, 12, 13, 14],
       [ 0,  0,  0, 18, 19],
       [ 0,  0,  0,  0, 24]])
```
`tril` - зануляем элементы выше главной диагонали
```python
np.tril(arr)
array([[ 0,  0,  0,  0,  0],
       [ 5,  6,  0,  0,  0],
       [10, 11, 12,  0,  0],
       [15, 16, 17, 18,  0],
       [20, 21, 22, 23, 24]])
```
### `trace`
`trace` - возвращает сумму главной и побочной диагонали
```python
np.trace(arr)
np.int64(60)
```