## Создание
Массив в numpy - это контейнер, который хранит одинаковые типы (почти всегда)
Чтобы создать массив на основе какого-то итерируемого объекта, то его нужно просто передать как параметр
```python
arr = np.array([1, 2, 3])  # array([1, 2, 3])
arr1 = np.array({"1": 2})  # array({'1': 2}, dtype=object)
```
В общем любой итерируемый объект
## Информация о массиве
Мы можем получить следующие свойства
`ndim` - кол-во измерений
`shape` - размерной массива
`dtype` - тип данных массива
### `ndim`
```python
arr_nested = np.array([[1, 2], [3, 4]])
print(arr_nested.ndim)  # 2
```
Массив имеет вложенность 2, поэтому возвращается 2.
Может быть и больше
```python
arr_nested = np.array(
    [
        [
            [1, 2],
            [3, 4]
        ],
        [
            [10, 20],
            [30, 40],
        ],
    ],
)
print(arr_nested.ndim)  # 3
```
### `shape`
Размерность массива. То есть по сколько элементов в каждом из измерений. 
```python
arr_nested = np.array(
    [
        [
            [1, 2],
            [3, 4]
        ],
        [
            [10, 20],
            [30, 40],
        ],
    ],
)
print(arr_nested.shape)  # (2, 2, 2)
```
Возвращается кортеж - `tuple`. 
![[Pasted image 20250402002820.png]]

### `dtype`
Возвращает тип значений в массиве
```python
arr = np.array([1, 2])
print(arr.dtype) # dtype('int64')
```
Причем если типы будут разные, он вернет что-то не очень понятно
```python
f = np.array([1, "q"])
print(f.dtype) # dtype('<U21')
```
## Генерация массива
Можно создавать массив, заполняя его уже какими-то значениями
`zeros` - массив нулей
`ones` - массив единиц
`full` - массив одинаковых переданных значений
`arange` - последовательность
### `zeros`
Первый параметр - форма, то есть тот же `shape` кортеж. А потом можно передать тип по желанию
```python
arr = np.zeros((2, 2))
print(arr)
# array([[0., 0.],
#      [0., 0.]])
```
По умолчанию выбирает тип `float64`
### `ones`
Аналогично, только единицами
### `full`
Аналогично, только вторым параметром надо передать значение для заполнения
```python
f = np.full(10, 2)
print(f)
# array([2, 2, 2, 2, 2, 2, 2, 2, 2, 2])
```
Тип по умолчанию тот же, что и тип значения для заполнения
### `arange`
Генерирует последовательно от и до. Может применять дробный шаг. Начало по дефолту 0. Правая граница также не включена
```python
np.arange(1, 10, 0.1)
#Output array([1. , 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. , 2.1, 2.2,
#       2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3. , 3.1, 3.2, 3.3, 3.4, 3.5,
#       3.6, 3.7, 3.8, 3.9, 4. , 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8,
#       4.9, 5. , 5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8, 5.9, 6. , 6.1,
#       6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8, 6.9, 7. , 7.1, 7.2, 7.3, 7.4,
#       7.5, 7.6, 7.7, 7.8, 7.9, 8. , 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7,
#       8.8, 8.9, 9. , 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8, 9.9])
```