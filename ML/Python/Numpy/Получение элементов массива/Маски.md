
Можно получать только те значение из массива, которые удовлетворяют маске
```python
arr = np.arange(5)
mask = [True, True, False, False, True]
print(arr[mask]) # array([0, 1, 4])
```
Благодаря этому можно получать легко значения через какой-то фильтр
```python
arr = np.array([1, 1, 1, 1, -1, 0, 10, -5])
print(arr[arr>=0]) # array([ 1,  1,  1,  1,  0, 10])
```
Маска возвращает новый массив, то есть не ту же ссылку на тот же массив, а ссылку на новую ячейку в памяти
Также можно использовать и маски и индексацию
```python
users = np.array(["Jon", "Alex", "Carry"])
visits = np.array(
    [
        [1, 2, 1, 5, 10, 0, 0],
        [1, 2, 1, 1, 0, 10, 15],
        [1, 2, 1, 5, 10, 34, 2],
    ],
)
print(visits[users=="Alex", 5:])
#Output array([[10, 15]])
```
То есть говорим: возьми строчки, у которых такой же индекс, какой и у Алекса в массиве `users`, а из получившегося возьми все значения после индекса 5
Маски можно инвертировать, для этого используется `~`. Маска `~(users="Alex")` вернет индексы, где пользователь не равен Alex.
Маски можно объединять логическими операторами
```python
m1 = users=="Alex"
m2 = users=="Jon"
m1 | m2 # логическое ИЛИ
m1 & m2 # логическое И
```
Эти логические операции будут поэлементно применены к значением в булевых масках. Но тут надо быть аккуратным. Вот так не работает
```python
visits[users=="Jon" | users=="Alex", 5:]
```
И вот так тоже:
```python
m1 = users=="Jon" | users=="Alex"
```
Нужно брать в скобки
```python
visits[(users=="Jon") | (users=="Alex"), 5:]
```


