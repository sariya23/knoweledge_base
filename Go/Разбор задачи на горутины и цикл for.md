[[Go]]
## Задача
Оригинальный материал - https://www.youtube.com/watch?v=Qf24zMzMmgI

Есть такой код:
```go
func main() {
    for i := 0; i < 5; i++ {
        go func() {
            fmt.Println(i)
        }()

    }
}
```
Вопрос: что выведется?

## Разбор
Прикол в том, что когда мы вызываем какую-то функцию через `go`, то горутина *не начинает выполнятся*, он просто кладется в *очередь* и когда она вызовется известно только планировщику. То есть вероятность, что 5 итераций цикла прокрутятся быстрее, чем у планировщика дойдут руки до хоть одной горутины. А после цикла у нас ничего нет, а так как это все в функции `main`, которая является главной горутиной и точкой входа, то после выхода из нее убиваются все дочерние процессы и программа ничего не выведет.

Нужно добиться того, чтобы что-то ждало завершения всех этих горутин. Тут на помощь придет waitGroup. 
```go
    var wg sync.WaitGroup
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            fmt.Println(i)
        }()
    }
    wg.Wait()
```
Каждую новую итерацию мы инкрементируем счетчик на 1. Когда срабатывает `Done` счетчик декрементируется. 

**Могут спросить:** а что если положить `Add` внутрь горутины? 
```go
func main() {
    var wg sync.WaitGroup
    for i := 0; i < 5; i++ {
        go func() {
            wg.Add(1)
            defer wg.Done()
            fmt.Println(i)
        }()
    }
    wg.Wait()
}
```
Ответ был выше: планировщик при виде `go func` только кладет в очередь эту горутину, но не начинает сразу же выполнять. Поэтому опять же цикл прокрутится, wait group нЕчего ждать, так как мы ни разу не увеличили счетчик и программа ничего не выполнит.

**Могут спросить**: а зачем `wg.Done` помещать в `defer`? 
Ответ простой. В данном случае у нас просто `print` и вероятность казуса крайне мала. Но у нас может быть и более сложная логика, например какие-то условия с `return`. Если сработает какое-то условие, то `wg.Done` просто не сработает и будет дедлок. **Из этого могут еще кое-что спросить**: а всегда ли выполняется `defer`? Прикол в том, что с такой ситуацией я уже сталкивался - ответ не всегда. Системный выход `os.Exit` или обертка над ним `log.Fatal` прям ВЫХОДЯТ СРАЗУ ЖЕ и `defer` не сработает.

**Могут спросить**: а что если перенести `defer` после принта?
```go
        go func() {
            fmt.Println(i)
            defer wg.Done()
        }()
```
`defer` срабатывает только если он положился в стек/зарегистрирован. Если в принте произойдет паника, то `defer` не выполнится, так как он еще не был зарегистрирован. Я не знал об этом - я думал компилятор как-то находит `defer` при входе в функцию и запоминает, что он есть. А оказывается он регистрируется только когда до него дошло выполнение 
```go
func deferTest() {
    a, b := 1, 0
    fmt.Println(a / b)
    defer fmt.Println("end")
}
```
Этот `defer` не выполнится, так как программа завершается до его регистрации. 

**Важный момент про waitGroup** - если мы передаем группу в функцию, то передавать нужно ее по **указателю**, так как если мы передадим ее по значению, все скопируется и увеличиваться будет счетчик внутри функции, а `Wait` ничего не будет знать об этих изменениях:
```go
    var wg sync.WaitGroup
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(wg sync.WaitGroup) {
            defer wg.Done()
            fmt.Println(i)
        }(wg)
    }
    wg.Wait()
```
Но тут сам компилятор подскажет, что мы делаем что-то не так. Значения в таком случае напечаются, но будет паника.

**Также в старых версиях** Go была проблема с переменной `i`. После прокрута всех итераций переменная `i` указывала на 5, так как она не создавалась каждый раз. Сейчас такой проблемы нет и переменная в цикле создается каждый раз заново.

**Могут еще спросить про ErrorGroup**. Эта штука помогает завершить все горутины, если хотя бы в одной возникла ошибка.