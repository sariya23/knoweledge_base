[[note]]
[[Go]]
Видос - https://www.youtube.com/watch?v=mvUiw9ilqn8

## Управление горутинами в Go
Существует 2 способа управлением ассинхронных задач - кооперативный подход и вытесняющий.
**При кооперативном** подходе переключение происходит явно, то есть мы сами указываем, когда можно отдать ресурс другой задаче
**При вытесняющем** подходе есть некий элемент, который наблюдает за выполнением и сам принимает решение о том, когда стоит переключить контекст

В Go используется смешанный подход. Во время компиляции компилятор расставляет метки, где скорее всего нужно будет переключать контекст. Объявить о переключении можно и явно, но лучше не надо. Компилятор расставит метки при следующих операциях:
- Операции с сетью
- Системные вызовы
- Вызовы функций
- Блокировки

## Синхронизация горутин
Синхронизация происходит через тип данных **канал**

## Аксиомы каналов
- Запись в неинициализированный канал блокирует поток навсегда
- Чтение из неинициализированного канала блокирует поток навсегда
- Запись в закрытый канал выдает панику
- Чтение из закрытого канала дает нулевое значение мгновенно

## Состояние гонки
Состояние гонки, это когда 2 горутины изменяют значение переменной в один и тот же момент времени.
Чтобы выявить моменты, где есть состояние гонки в Go есть инструмент race detector. Нужно добавить флаг `--race` при запуске. Он дает только true positive результаты, то есть он может найти и не все состояния, но если найдет, то они точно будут иметь его. 

## Мьютексы
С состоянием гонки помогут справиться мьютексы. 
При вызове метода из одного потока можно залочить его, чтобы даже если другой метод из другого потока зайдет в него, изменения произошли последовательно.
#### Что нельзя делать с мьютексами
- Нельзя встраивать объект мьютекса в структуру
- Нельзя хранить ссылку на мьютекс в структуре, так как у каждого инстанса будет ссылка на один и тот же мьютекс
- Методы, которые блокируют или разблокируют мьютекс должны иметь ссылочный ресивер, иначе блокировка будет срабатывать только на копию
