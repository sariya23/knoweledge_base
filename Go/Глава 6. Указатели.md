[[Go]]
## Указатели
У синтаксиса указателей два символа - `&` и `*`. У звездочки в контексте указателей 2 значения. 
**З**вездочка (**з**-**з**начение) позволяет получить **з**начение по адресу памяти
**А**мперсант (а-адрес) позволяет получить адрес памяти, где хранится значение

```go
x := 10
pointerX := &x // 0x123a583f
fmt.Println(*pointerX) // 10
```

Также можно создать указатель, который ни на что не указывает, он будет иметь значение `nil`
```go
var s *string
```
### Второе значение звездочки
Звездочка используется не только для получения значения из адреса, но для и указания типа.
То есть такая запись:
```go
def f(x *int) {

}
```
Означает, что функция принимает указатель на тип `int`. Ее вызов:
```go
f(&x)
```
То есть указатель - это именно адрес памяти. И когда говорят: "Принимает указатель", это значит, что нужно передавать адрес переменной.

## Указатели на константы и литералы
Есть также функция `new`, которая создаст указатель на нулевое значение заданного типа:
```go
    x := new(int)
    println(*x) // 0
```
Нельзя использовать `&` перед простыми типами - чисел, строк, булевые значения. Чтобы создать указатель на них, нужно сначала положить их в переменную. 
Также нельзя создавать указатели на константы, так как они есть только во время компиляции.
## Указатели и структуры
Не нужно разыменовывать указатель для получения значения поля структуры:
```go
timmy := &struct{
	name string
	age int
}{
	"qwe",
	10,
}
println(timmy.name) // qwe
```
## Указатели и массивы
Указатели на массивы также позволяют получать значения без разыменовывания
```go
    arr := &[...]int{1, 2, 3, 4}
    println(arr[0]) // 1
```
## Указатели как параметры
Функции при вызове копируют значение из переменной в параметр и через разыменовывание мы можем изменить значение, на которое указывает указатель, тем самым изменив переменную во вне
```go
func update(x *int) {
    *x = 20
}

func main() {
    n := 10
    update(&n)
    println(n) // 20
}
```

## Различия между картами и срезами
Карты в Go реализованы как указатель на структуру, поэтому передав карту как параметр в функцию, скопируется указатель на нее. Поэтому лучше давать на вход функции структуру, а не мапу

Со слайсами тут вообще веселуха, а точнее гемор. Слайсы реализованы как структура с тремя полями: длина, емкость и указатель на блок памяти.
![[slice_internals.png]]
Изменения, которые будут внесены в копию отобразятся в оригинале, но если длина среза увеличится, это не произойдет. Оригинальный слайс не увидит эти новые элементы. Это происходит потому, что при копировании куда-либо, копируется длина, емкость и указатель на область памяти. Изменив значение в слайсе изменения будут видны в обоих, так как указатель указывает на одну и ту же область в памяти.
![[memory_for_copy_and_orig_slice.jpg]]\

Но если изменится изменится емкость, то указатель станет указывать на более большой блок памяти
![[increase_cap_new_slice.jpg]]

Если в срез добавится новое значение, но емкость не изменится, то длина копии изменится, а оригинала нет, но значение добавится в общий блок памяти. Оригиналу не будут видны элементы за пределами его длины:
```go
    x := make([]int, 3, 5}
    y := x
    y = append(y, 30)
    fmt.Println(x) // [0 0 0]
    fmt.Println(y) // [0 0 0 30]
    y[0] = 9
    fmt.Println(x) // [9 0 0]
```

## Производительность указателей
Лучше их просто так не использовать, так как это замедляет работу сборщика мусора. Если указатель указывает на типы, в которох нельзя четко узнать размер (слайсы, мапы), то их нельзя положить в стек, поэтому они кладутся в кучу. Чем больше переменных в куче, тем дольше будет работать сборщик.