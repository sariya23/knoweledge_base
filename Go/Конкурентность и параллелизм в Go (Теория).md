[[Go]]
**Конкурентность** - управление передается от одного потока к другому
**Параллельность** - потоки выполняются одновременно
![[Pasted image 20241110114511.png]]

![[Pasted image 20250217171333.png]]

**Проблемы**:
- Непредсказуемость. При параллельности тяжело предсказать какой поток будет выполнять эту часть задачи. А при конкретности когда поток будет перехвачен 
- Синхронизация
- Багфикс. Сложно отлаживать конкурентный код
- Общие данные

**Процесс** - это отдельная единица выполнения
Особенности:
- Раздельные ресурсы
- Раздельная память
- Раздельный стек

Есть несколько способов менеджить процессы при многозадачности - кооперативная и вытесняющая
Кооперативная - это когда процессы сами сообщают друг другу, что могут отдать управление
Вытесняющая - это когда ОС сама решает когда отдать управление от одного процесса другому

**Поток** - это набор операций, выполняемых независимо в одном процессе
Особенности:
- Общие ресурсы
- Общая память
- Раздельный стек

**Горутина** - это легковесный поток внутри потока ОС
Особенности:
- Общие ресурсы
- Общая память
- Общий стек

Также горутина - это структура, которая выполняет переданную функцию. Самый тяжелый элемент структуры - stack.  По умолчанию он 2Кб. Максимальный размер стека - 1 Гб для 64 ОС и 256 Кб для 32 ОС

## Runtime и планировщик Go
## Runtime
В рантайме есть 3 базовые структуры:
- `m` - реальный поток ОС, создается по числу виртуальных процессов
- `p` - виртуальный процесс, представляет каждое виртуальное ядро
- `g` - горутина. Создается как минимум одна для `main`
## Scheduler
Планировщик управляет `g`. Этим занимается не ОС
Переключение может быть выполнено:
- Запускается новая горутина
- Собирается мусор
- Запускается синхронизация
- Происходит системный вызов
- Происходит аллокация стека
- Рандомно по таймеру

# Каналы
Канал - это механизм взаимодействия между горутинами

## Не буферизированные каналы
```go
package main

import (
	"fmt"
	"time"
)

func main() {
	intCh := make(chan int)

	fmt.Println(len(intCh), cap(intCh))

	go func() {
		time.Sleep(2 * time.Second)
		fmt.Println("start go")
		intCh <- 10
	}()

	fmt.Println("Wait go")
	fmt.Println("Result", <-intCh)
}
```
Используем не буферизированный канал. В принте в конце мы блокируем `main`, так как читаем из не буферизированного канала. Горутина разблокируется, когда в этот канал запишется сообщение.

Как словить дедлок. Он происходит когда все горутины блокируются
```go
package main

import (
	"fmt"
	"time"
)

func main() {
	ch := make(chan int)

	go func() {
		time.Sleep(time.Second * 2)
		fmt.Println("Start")
		ch <- 10
	}()

	fmt.Println("wait")
	<-ch
	<-ch
}
```
При первом чтении из канала все ок - мы получаем записанное значение в горутине. Но второе чтение заблокирует все, так как в канал больше никто не писал. Также дедлок можно словить так
```go
func main() {
	ch := make(chan int)
	fmt.Println("wait")
	fmt.Println("read from chan", <-ch)

	go func() {
		time.Sleep(2 * time.Second)
		fmt.Println("start go")
		ch <- 10
	}()
}
```
Тут мы читаем из канала еще до того, как горутина положилась на стек. Поэтому все лочится

## Буферизированные каналы
Писать в закрытый буферизированный канал нельзя - будет паника. Читать можно. Поэтому при чтении мы должны быть уверены, что записи в канал больше не будет
При передаче буферизированного канала в функцию можно ограничить операции, которые можно с ним выполнять
![[Pasted image 20241110125548.png]]

## Select
```go
select {
    case x, ok := <- intCh:
        fmt.Println("Read int")
    case x, ok := <- stringCh:
        fmt.Println("Read string")
    case sender <- "Hello":
        fmt.Println("sended")
    default:
        fmt.Println("Def")
}
```
В кейсах вы указываем какие-то операции над каналами. Если ни одну операцию над каналами выполнить нельзя, то срабатывает `default`. Если можно выполнить операцию над несколькими кейсами, то срабатывает рандомный

# Примитивы синхронизации
## `Mutex`, `RWMutex`
Обычный мьютекс запрещает только запись. Но в го также есть `RWMutex`, который позволяет залочить или запись или чтение
```go
	m := new(sync.RWMutex)
	m.Lock()   // lock write
	m.Unlock() // unlock write

	m.RLocker() // lock Read
	m.RUnlock() // unlock read

	m1 := new(sync.Mutex)
	m1.Lock()
	m1.Unlock()

```
## `WaitGroup`
Позволяет поставить ожидание за завершение n горутин

## `Atomic`
Все атомики реализуют Load, Store, Swap, CompareAndSwap

## `Context`
Контекст нужен для передачи методанных по цепочке и обработке завершений
```go
func main() {
	intCh := make(chan int)

	ctx := context.Background()
	ctx, cancel := context.WithTimeout(ctx, time.Second*2)

	for {
		select {
		case intCh <- 1:
			fmt.Println("sended")
			cancel()
		case <-ctx.Done():
			fmt.Println("timeout")
			return
		}
	}
}
```
Напечатает `timeout`, так как читать из канала некому