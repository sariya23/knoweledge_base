[[Go]]

## Основы тестирования
- Пакет тестирования - `testing`
- Основная утилита тестирования - `go test`
- Размещение тестов в том же пакете, где и логика
- Имя файла с тестами должно оканчиваться на `_test.go`
- Имена функций начинаются со слова `Test`. Если тестируется не экспортируемая функция, то после `Test` нужно добавить `_`

Пример теста:
```go
func Test_addNumbers(t *testing.T) {
    result := addNumbers(2, 2)
    if result != 4 {
        t.Error("Ошибка")
    }
}
```
По умолчанию запускают тесты в текущем каталоге, если нужны тесты в текущем каталоге и во вложенных, то нужно указать `go test ./...`. Для расширенной информации нужно добавить флаг `-v`

### Вывод неудачного результата
Методы экземпляра тестирования `Error` и `Errorf` работают так же как и `Print` и `Printf`. Если мы вызываем `Error/f`, то нам высветится сообщение об ошибке, но тест продолжит выполнятся
```go
func Test_addNumbers(t *testing.T) {
    result := addNumbers(3, 2)
    if result != 6 {
        t.Errorf("Ошибка. Получил %d, а должен был %d", result, 6)
    }
    if result != 4 {
        t.Errorf("Ошибка. Я получил %d, а должен был %d", result, 4)
    }
}
```
```
    adder_test.go:8: Ошибка. Получил 5, а должен был 6
    adder_test.go:11: Ошибка. Я получил 5, а должен был 4
```
Если нам нужно, чтобы функция тестирования прекратила работу, нужно использовать `Fatal` или `Fatalf`. В таком случае завершение **этого** теста завершится

## SetUp и TearDown
### `TestMain`
Если нужно сделать что-то до тестов и после, то можно воспользоваться функцией `TestMain`
```go
func TestMain(m *testing.M) {
    fmt.Println("SET UP")
    os.Create("test.txt")
    
    exitVal := m.Run()
    
    fmt.Println("TEAR DOWN")
    os.Remove("test.txt")
    
    os.Exit(exitVal)
}
```
При запуске тестов через `go test` для пакета с этой функцией будет запускаться именно она, а в ней уже через `m.Run` запустятся остальные тесты. Этот метод возвращает код выхода из системы.
Функция `TestMain` выполняется только один раз и в пакете может быть только одна функция `TestMain`.
Она может быть полезна при:
- Настройка внешних ресурсов (БД)
- Тестируемый код зависит от переменных уровня пакета, которые нужно создать

### `Cleanup`
Если нам нужно управлять временными ресурсами для каждого теста, то надо использовать метод `Cleanup` экземпляра `testing.T`. Этот метод принимает на вход функцию без принимаемых и возвращаемых значений
```go
func createFile(t *testing.T) (string, error) {
    f, err := os.Create("tempFile")
    if err != nil {
        return "", err
    }
    t.Cleanup(func() {
        os.Remove(f.Name())
    })
    return f.Name(), nil
}

func TestFileProcessing(t *testing.T) {
    fName, err := createFile(t)
    if err != nil {
        t.Fatal("asd")
    }
    /// process
}
```
Это можно сделать и с помощью `defer`, но `Cleanup` полезен, когда нужно что-то настраивать через вспомогательные функции, как в примере выше

## Расположение тестовых данных
Go резервирует каталог `testdata` для хранения тестовых данных. При чтении данных в этом каталоге нужно использовать относительные ссылки на файл - [пример](https://github.com/learning-go-book/test_examples)

## Кэширование результатов теста
Го использует закэшированный скомпилированный файл, если не вносились изменения. С тестами также. Если мы ничего не меняли в коде - ни в тестовом, ни в каком, то при запуске тестов результат возьмется из кэша. Если нужно, чтобы тесты выполнялись всегда, то нужно добавлять флаг `-count=1`

## Тестирование публичного API
Тесты находятся в том же пакете, что и логика. Это позволяет тестировать как публичные функции, так и не экспортируемые. Если нужно протестировать только публичный API, то в Го есть соглашение на этот счет.
Тесты по прежнему лежат в том же каталоге, что и логика, но в качестве имени пакета указывается `имяПакета_test`
```go
package adder_test
import (
    "main/adder"
    "testing"
)

func TestAddNumbers(t *testing.T) {
    var (
        a   = 2
        b   = 3
        res = 5
    )
    if r := adder.AddNumbers(a, b); r != res {
        t.Fatalf("Got %d, expected %d", r, res)
    }
}
```
```
.
├── adder
│   ├── adder.go
│   └── adder_test.go
├── go.mod
└── main.go
```
Зачем это? Взаимодействие из другого пакета с логикой поможешь сымитировать черный ящик без доступа к не экспортируемым функциям.

## Сравнение результатов в тестах
Если нужно сравнивать что-то составное, то можно воспользоваться пакетом `reflect`, но в тестах нам хотелось бы видеть более подробное сравнение - что где не сходится и тд. В Go для этого есть модуль `go-cmp` - https://github.com/google/go-cmp
```go
func TestNew(t *testing.T) {
    expected := adder.User{Name: "Nikita", Age: 29}
    res := adder.User{
        Name: "Nikitaaaa",
        Age:  90,
    }
    if diff := cmp.Diff(expected, res); diff != "" {
        t.Fatal(diff)
    }
}
```
```
--- FAIL: TestNew (0.00s)
    adder_test.go:30:   adder.User{
        -       Name: "Nikita",
        +       Name: "Nikitaaaa",
        -       Age:  29,
        +       Age:  90,
          }
        
FAIL
```
Если совпадение полное, то функция вернет пустую строку, если же нет, то строку с несоответствиями.
Если нам не нужно учитывать что-то при сравнении (например, какое-то поле в структуре), то можно написать функцию, как будут сравниваться объекты (`__eq__` в Python)
```go
    comparer := cmp.Comparer(func(x, y adder.User) bool {
        return x.Age == y.Age
    })
```
А потом передать ее в функцию `Diff`
```go
if diff := cmp.Diff(expected, res, comparer); diff != ""
```

## Табличные тесты (параметризованные)
Функция для теста:
```go
func Calc(a, b int, op string) (int, error) {
    switch op {
    case "+":
        return a + b, nil
    case "-":
        return a - b, nil
    case "*":
        return a * b, nil
    case "/":
        return a / b, nil
    default:
        return 0, fmt.Errorf("unknow op %s", op)
    }
}
```
Для параметризации теста в файле с тестов нужно создать анонимную структуру с нужными нам полями, а дальше объявить срез этих структур с тестовыми данными:
```go
testData := []struct{
    caseName string
    a int
    b int
    op string
    expected int
    err string
}{
    {"add", 1, 2, "+", 3, ""},
    {"sub", 2, 2, "-", 0, ""},
    {"mult", 2, 2, "*", 4, ""},
    {"div", 2, 2, "/", 1, ""},
    {"unk op", 2, 2, "p", 0, "unknown op p"},
}
```
В самом же тесты мы должны запустить цикл по этому срезу и запускать под тест с помощью метода  `t.Run(name string, t *testing.T)`
```go
func TestCalc(t *testing.T) {
    for _, v := range testData {
        t.Run(v.caseName, func(*testing.T) {
            res, err := adder.Calc(v.a, v.b, v.op)
            if res != v.expected {
                t.Errorf("got %d, expected %d", res, v.expected)
            }
            var errMsg string
            if err != nil {
                errMsg = err.Error()
            }
            if errMsg != v.err {
                t.Errorf("Expected error `%s`, got `%s`", v.err, errMsg)
            }
        })
    }
}
```
Выглядит как лютое аниме.

## Проверка степени покрытия кода
Для того, чтобы узнать степень покрытия кода:
```bash
 go test -v -cover -coverprofile=c.out
```
Последний флаг говорит о том, что результат нужно направить в файл `c.out`. Дальше этот файл можно представить в виде html, чтоб подсветились покрытые и непокрытые части кода:
```bash
 go tool cover -html=c.ou
```
![[Pasted image 20240816174213.png]]

## Тесты производительности
Из коробки в Go поддерживается сравнительное тестирование.  
Есть функция, которая считывает данные из файла:
```go
func FileLen(f string, bufsize int) (int, error) {
    file, err := os.Open(f)
    if err != nil {
        return 0, err
    }
    defer file.Close()
    count := 0
    for {
        buf := make([]byte, bufsize)
        num, err := file.Read(buf)
        count += num
        if err != nil {
            break
        }
    }
    return count, nil
}
```
С помощью сравнительных тестов мы можем выяснить, какой буфер будет самый выгодный. Чтобы вообще посмотреть инфу по тест надо запустить тесты с флагом `-bench=regex`. В регулярном выражении нужно указать имена тестов. Если поставить точку, то запустятся все сравнительные  тесты. Если добавить флаг `-benchmem`, то выведется информация о памяти
```go
var blackhole int

func BenchmarkFileLen(b *testing.B) {
    for i := 0; i < b.N; i++ {
        res, err := adder.FileLen("testdata/data.txt", 1)
        if err != nil {
            b.Fatal(err)
        }
        blackhole = res
    }
}
```
В каждом сравнительном тесте должен быть цикл от 0 до `b.N`. Это нужно для того, чтобы произошел вызов теста несколько раз, чтобы получить точные данные
![[Pasted image 20240816180506.png]]
- `139058` - сколько потребовалось выполнить тест для стабильного результата
- `7704 ns/op` - время, которое потребовалось на выполнение 1 сравнительного теста (1 итерация цикла)
- `132 B/op` - кол во байт, выделяемое на один сравнительный тест
- `7 allocs/op` - кол во выделяемых байт в куче

```go
func BenchmarkFileLen(b *testing.B) {
    for _, v := range []int{1, 10, 100, 1000, 10_000} {
        b.Run(fmt.Sprintf("FileLen-%d", v), func(b *testing.B) {
            for i := 0; i < b.N; i++ {
                res, err := adder.FileLen("testdata/data.txt", 1)
                if err != nil {
                    b.Fatal(err)
                }
                blackhole = res
            }
        })
    }
}
```
![[Pasted image 20240816181107.png]]
Параметризированный сравнительный тест

## Теги сборки
Компилятор позволяет указывать *теги сборки* с помощью специального комментария в 1 строчке файла `// +build`.  Если указать `// +build unit`, а потом `go test -tags unit`, то запустятся только те тесты, которые находятся в файле с этим тегом
Также можно использовать флаг `-short`, а  в тестах писать такую конструкцию:
```go
if testing.Short() {
	t.Skip(reason)
}
```
При запуске тестов с этим флагом будут скипаться все тесты, в которых есть такая конструкция
