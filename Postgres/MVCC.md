[[Postgres]]

```sql
db=*> table test.account;
 id | balance
----+---------
  1 |     100
  2 |     200
```

В одной транзакции мы будем обновлять поле `balance`, а в другой читать значение этого поля

1:
```sql
db=> begin;
BEGIN
db=*> update test.account set balance = 1 where id = 1;
UPDATE 1
```
2:
```sql
db=*> table test.account;
 id | balance
----+---------
  1 |     100
  2 |     200
(2 строки)
```
Как видно, вторая транзакция не ожидает завершения первой и спокойно читает *старые* данные. 
Эти 2 транзакции видят разные версии одних и тех же данных. Это реализовано с помощью MVCC - multyversion concurently control. 
## Механизм MVCC
Такая многоверсионность и понимание постгреса, что показывать, а что нет, достигается через номера транзакций и поля `xmin` и `xmax`. 
- `xmin` - тут лежит номер транзакции, которая создала текущую версию строки
- `xmax` - тут лежит номер транзакции, которая изменила или удалила версию строки. Если `xmax=0`, то сейчас актуальная версия
Посмотрим, какие xmin и xmax у ***первой*** транзакции, которая изменяла поле balance
```sql
db=*> select id, balance, xmin, xmax from test.account;
 id | balance | xmin | xmax
----+---------+------+------
  2 |     200 |  778 |    0
  1 |       1 |  779 |    0
```
Видим, что сейчас для этой транзакции версии строк актуальные (xmax=0). Также выведем текущий номер транзакции
```sql
db=*> select txid_current();
 txid_current
--------------
          779
```
Текущая транзакция имеет номер 779, как раз тот, что указан в `xmin` с `id=1`.
Во ***второй*** транзакции  ситуация такая:
```sql
db=*> select id, balance, xmin, xmax from test.account;
 id | balance | xmin | xmax
----+---------+------+------
  1 |     100 |  778 |  779
  2 |     200 |  778 |    0
```
Видно, что для второй транзакции поле с id=1 имеет другие значения. Тут `xmin` равен 778, то есть версия транзакции, которая создала текущую версию строки. А вот `xmax` имеет номер 779, как раз той, первой транзакции, которая изменила поле `balance`. То есть транзакция на самом деле видит, что строка изменилась, но показывает все равно текущую версию.
Если мы сделаем коммит в первой транзакции, то второй эти изменения уже отобразятся
```sql
db=*> select id, balance, xmin, xmax from test.account;
 id | balance | xmin | xmax
----+---------+------+------
  2 |     200 |  778 |    0
  1 |       1 |  779 |    0
```
`xmax` стал равен 0, а `xmin` заменилось на номер транзакции, которую мы только что закоммитили.
## VACUUM
Неактуальные версии строк не удаляются, а все еще хранятся на диске. Их удалением занимается процесс `vaccum`, который крутится и периодически чистит неактуальные строки. Просмотреть неактуальные строки можно с помощью расширения `pg_dirtyread`. 
Очистить устаревшие строки можно и в ручную, просто выполнив команду `vacuum;`. Но место на диске не очистится, просто эти слоты станут свободны, чтобы их заняли другие устаревшие строки.
Полностью очистить место можно с помощью `vaccum full`, но такой способ заблокирует таблицу. Вместо этого можно воспользоваться утилитой `pg_repeack`