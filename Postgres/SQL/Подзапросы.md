[[Postgres]]
### Ключевое слово ALL
Ключевое слово `ALL` используется для того, чтобы выбрать только те записи, условия которых удовлетворяет всех строкам из подзапроса
```sql
SELECT title, author, price
FROM Books
WHERE price > ALL (SELECT price
                   FROM Books
                   WHERE author = 'Chuck Palahniuk');
```
Здесь выберутся только те записи, у которых цена книга больше каждой цены книг Чака Паланкина
### Ключевое слово ANY
Аналогично `ALL`, только условие будет истино, если хотя бы одна запись таблице удовлетворит условию
```sql
SELECT title, author, price
FROM Books
WHERE price < ANY (SELECT price
                   FROM Books
                   WHERE author = 'Chuck Palahniuk');
```
Если цена текущей книги ниже хотя бы одной книги Чака Паланкина, то берем эту запись
### Некоррелированные подзапросы
Некоррелированный подзапрос - это такой подзапрос, который не зависит от основного запроса и может выполнятся самостоятельно
```sql
SELECT title, critic_score
FROM Books
WHERE critic_score = (SELECT MIN(critic_score)
                      FROM Books);
```
Этот подзапрос некоррелированный, так как он всегда вовзращает одинаковый результат. Мы можем выполнить его отдельно и получить такой же результат. Да и вообще этот запрос можно переписать так
```sql
SELECT title, critic_score
FROM Books
WHERE critic_score = 39
```
### Коррелированные подзапросы
При коррелированном подзапросе резльутат подзапроса зависит от значения поля внешнего запроса. Например, нужно посчитать, сколько в таблице пар записей, в которых разница между датами 1 день (это я сам придумал, не слушайте). Более трезвый пример: требуется написать запрос, извлекающий данные о книгах, пользовательская оценка которых больше, чем у предыдущей книги в таблице, то есть у книги с идентификатором на один меньше. Тут есть зависимоть внешнего запроса и подзапроса
```sql
SELECT title, user_score
FROM Books
WHERE user_score > (SELECT user_score
                    FROM Books AS InnerBooks
                    WHERE id = Books.id - 1);
```
### Подзапросы с несколькими полями
Результат подзапроса можно сраванивать с несколькими полями:
```sql
SELECT title, critic_score, user_score
FROM Books
WHERE (critic_score, user_score) = (SELECT MIN(critic_score), MIN(user_score) FROM Books);
```
## Приколюхи
### Приколюха 1
Так как подзапрос возвращает таблицу, можно делать из него выборку:
```sql
SELECT *
FROM (SELECT title, author, price
      FROM Books) AS BooksCopy;
```
Но ему обязательно должно быть присвоен псевдоним
### Приколюха 2
Если из подзапроса возвращается единственное значение, то она также может быть просто извлечено селектом
```sql
select (select max(task_id) from actions);
```
### Приколюха 3
Если подзапрос возвращает пустую таблицу, то возвращается `null`
```sql
select (select task_id from actions where task_id = 10000) is null; -- true
```

