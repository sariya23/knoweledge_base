[[Postgres]]

Составной индекс можно навесить на несколько колонок. Вот так
```sql
create index on test.entity(name, address)
```
Но работать он будет только в особых случаях. Он будет работать, если:
```sql
select * from test.entity where name='aaa';
```
Или
```sql
select * from test.entity where name='aaa' and address='bbb';
```
Все. В таком случае индекс работать не будет:
```sql
select * from test.entity where address='bbb';
```
Почему так происходит? Индекс - это сбалансированное дерево. Когда мы накидываем индекс на несколько колонок, то данные в индексе сначала отсортированы по первой колонке, потом по второй и так далее. 
Вот так
```
(a, b)
(1, 10),
(2, 20),
(2, 5)
```
Если мы фильтруем только по `a`, то все ок, планировщик знает откуда искать. Если по `a` и `b`, то тоже все ок. Но если только по `b`, то планировщик не знает откуда начинать искать, так как все отсортировано сначала по `a`, потом по `b`. Поэтому он сначала пробегается по `a`, а потом уже ищет `b`, а это равносильно Seq Scan.
Таже есть такая штука как Covering Index. Это когда запрос содержит все запрашиваемые строки, что и в индексе. Поэтому все данные можно взять из индекса, не идя даже в таблицу
