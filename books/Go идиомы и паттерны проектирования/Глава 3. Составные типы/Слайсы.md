[[Глава 3. Составные типы]]
## Срезы
### Способы создания
#### Литерал среза
```go
x := []int{1, 2, 3}
```
При создании среза не нужно указывать размер.
#### Разряженный срез
```go
x := []int{2: 90, 8: 100, 2} // [0 0 90 0 0 0 0 0 100 2]
```

#### Нулевой срез
```go
var x []int
```
Нулевое значения среза не как у массива - оно будет `nil`.  Это идентификатор показывающий, что типа нет

Срезы являются не сравнимыми. Единственное с чем можно сравнить срез - `nil`

## Функция `append`
Используется для увеличения срезов.
```go
    var x []int
    x = append(x, 10)
    x = append(x, 20, 30, 40)
    x = append(x, []int{50, 60}...)
    fmt.Println(x) // [10 20 30 40 50 60]
```
Возвращает увеличенный срез.
## Емкость среза
У среза есть не только длина, но и емкость - кол-во свободных ячеек для новых элементов. У среза может быть длина 10, а емкость 12.  Когда длина среза становится равна емкости, происходит выделение новых ячеек памяти под срез, копирования и вставка нового элемента. Емкость среза увеличивается по специальному алгоритму. Это затратная операция, поэтому при создании срезов лучше использовать функцию `make`. 
![[Алгоритм для срезов.jpg]]
## Функция `make`
Эта функция позволяет создавать срезы с указанной длиной или емкостью. 
```go
x := make([]int, 5) // len = 5, cap = 5
y := make([]int, 0, 5) // len = 0, cap = 5
z := make([]int, 5, 10) // len = 5, cap = 10 
```
Емкость среза должны быть больше длины! Когда создается срез с ненулевой длиной, то он заполняется дефолтными значениями указанного типа.

## А как создавать то?
Если неизвестно, сколько будет элементов, то лучше создавать срез с нулевой длиной и ненулевой емкостью. 
Если известно, сколько будет элементов, то можно создать его с нужной длиной и заполнять его через `[]`. 

## Срезания срезов
Можно получать срез на основе уже имеющегося среза.
```go
    x := []int{1, 2, 3, 4, 5}
    fmt.Println(x[2:5]) // [3 4 5]
```
Только тут есть небольшая проблема - срезы имеют общую область памяти с родительским срезом.
```go
    x := []int{1, 2, 3, 4, 5}
    y := x[1:4]
    y[1] = 90
    fmt.Println(x) // [1 2 90 4 5]
    fmt.Println(y) // [2 90 4]
```
![[Общая память срезов.jpg]]
То есть меняя родительский или дочерний срез меняться будет обратный. 
Если использовать `append`, то все становится еще сложнее.
```go
    x := []int{1, 2, 3, 4, 5}
    y := x[:2]
    y = append(y, 30)
    fmt.Println(x) // [1 2 30 4 5]
    fmt.Println(y) // [1 2 30]
```
При создании дочернего среза он получает емкость равную исходному срезу c вычитанием смещения:
```go
    x := []int{1, 2, 3, 4, 5}
    y := x[3:]
    fmt.Println(cap(x), cap(y)) // 5 2
```
```go
    x := []int{1, 2, 3, 4, 5}
    y := x[:2]
    fmt.Println(cap(x), cap(y)) // 5 5
```
Если в дочерний срез добавить элементов, больше чем его вместимость, то произойдет копирование, а значит создастся новый срез, несвязанный с оригиналом. Но лучше на это не рассчитывать и либо вообще использовать `append`, либо ограничивать область памяти для дочерних срезов.

Полное выражение среза также включает в себя еще одно значение, которое означает последнюю позицию в рамках емкости родительского среза, которая доступна для подсреза. Это позволяет защититься от функции `append`.
```go
    x := []int{1, 2, 3, 4, 5}
    y := x[:2:2]
    y = append(y, 100)
    fmt.Println(x) // [1 2 3 4 5]
    fmt.Println(y) // [1 2 100]
```
## Преобразование массивов в срезы
Если взять срез с массива, то вернется срез, но он также будет использовать общую с массивом память. 

## Функция `copy`
Чтобы создать независимый срез от родительского, используется функция `copy`. При копировании емкость не играет роли, только длина. 
Она принимает 2 параметра - целевой срез и исходный. Она копирует значения из исходного среза в целевой. Кол-во скопированных значений зависит от длины наименьшего.
```go
    x := []int{1, 2, 3, 4, 5}
    y := make([]int, 3)
    n := copy(y, x)
    fmt.Println(y, n) // [1 2 3] 3
    y[0] = 100
    fmt.Println(x) // [1 2 3 4 5]
```

То есть она позволяет создать вообще независимый "срез"
Если длина целевого среза (`y`), больше длины среза, из которого копируем, то оставшиеся значения заполнятся дефолтынми значениями этого типа
```go
    x := []int{1, 2, 3, 4, 5}
    y := make([]int, 3)
    copy(y, x[1:3])
    fmt.Println(y) // [2 3 0]
```

Также можно копировать части среза друг в друга:
```go
    x := []int{1, 2, 3, 4, 5}
    copy(x[:2], x[2:])
    fmt.Println(x) // [3 4 3 4 5]
```
То есть скопировать в первые два элемента все элементы со второго, но так как кол-во копируемых значений определяется наименьшей из длин срезов, скопируется только 3 и 4.