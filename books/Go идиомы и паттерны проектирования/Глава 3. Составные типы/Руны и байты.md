[[Глава 3. Составные типы]]
## Строки, руны, байты
Вот тут создатели Го ультанули и дакую дичь со строками сделали, что капец. Наверно, из-за того, что создатели UTF8 также являются и создателями Go. "Мы же такие классные, почему мы нашу UTF8 в го не завести". И под завести я имею ввиду, что тут строки - это последовательность байт. А так как символы к UTF8 могут занимать больше чем 1 байт, происходит это:
```go
    s := "hello 😀"
    fmt.Println(len(s)) // 10
```
Смайлик то занимает 4 байта. То есть функция `len` возвращает не кол-во символов, а кол-во байт в строке.
```go
    s := "hello 😀"
    for _, v := range s {
        fmt.Println(v)
    }
    // 104
	// 101
	// 108
	// 108
	// 111
	// 32
	// 128512
```

```python
>>> s = "hello 😀"
>>> print(len(s))
7
>>> for i in s:
...     print(i)
...
h
e
l
l
o

😀
```
Первый листинг - легкие курильщика, второй листинг - легкие здорового человека. 
Чтобы получать кол-во символов в строке, нужно подключать пакет:
```go
package main

import (
    "fmt"
    "unicode/utf8"
)

func main() {
    s := "hello 😀"
    fmt.Println(utf8.RuneCountInString(s)) // 7
}
```
И это еще не все приколы. Вот, например еще один:
```go
    s := "hello 😀"
    fmt.Println([]byte(s)) // [104 101 108 108 111 32 240 159 152 128]
    fmt.Println([]rune(s)) // [104 101 108 108 111 32 128512]
```
Так как смайлик занимает больше 1 байта, при преобразовании строки в слайс байтов появляется дополнительно 3 элемента. А так как руна можно представлять собой кодовую точку в виде Unicode (32 бита), то и значение одно.
Ну и вот:
```go
    n := 97
    fmt.Println(string(n)) // a
```
Со вторым еще можно согласиться, но вот преобразовывать *так* строку в слайс...