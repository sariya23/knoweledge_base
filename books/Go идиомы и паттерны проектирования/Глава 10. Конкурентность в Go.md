[[Go идиомы и паттерны проектирования]]

Я вообще практически не знаком с конкурентным программированием. Глава мне не очень понравилась, так как примеров мало, а если они и есть, то они очень абстрактные. Есть очепятки, какие-то размытые понятия в теории. Что-то из главы я и узнал, но очень поверхностно.

## Горутины
Одной из ключевых концепций в модели конкурентности Go являются **горутины**. Горутины - это абстракция на потоками ОС. Их основное преимущество в том, что они легкие и управление ими происходит на уровне программы, а не на уровне ОС. 
Чтобы запустить горутину, перед функцией нужно приписать ключевое слово `go`
`main` - это тоже горутина, главная. Когда она завершается - завершается все

## Каналы
Каналы - это средство общения горутин. 
Создание канала происходит с помощью функции `make`
```go
ch1 := make(chan int) // небуферезированный канал
ch2 := make(chan int, 10) // буферезированный канал
```
Каналы - это ссылочный тип. Поэтому так же как и в случае со слайсами, при передаче канала в функцию, ей передает указатель на канал. Нулевым значением для канала является `nil`

### Чтение, запись и буферизация
Взаимодействие с каналами возможно через символ `<-`. В зависимости от того, где находится канал от этого символ происходит либо чтение, либо запись
```go
ch := make(chan int)
ch <- 10 // запись
v := <- ch // чтение
```
Чтобы показать, что происходит только чтение из канала: `ch <- chan type`, чтобы показать, что только запись в канал: `ch chan <- type`

### Цикл `for-range` для каналов
В цикле можно получить значения из канала:
```go
for v := range ch {
	///
}
```

### Закрытие канала
Чтобы явно закрыть канал, нужно использовать функцию `close(chan)`. Запись в закрытый канал или повторное его закрытия приведут к панике. Но чтение из закрытого канала возможно. Если канал закрыт и без значений, то чтение из любого типа канала вернет нулевое значение. 
Чтобы определить, нулевое это значение или настоящее нужно как и в случае в мапами использовать идиому ok-запятой:
```
v, ok := <- ch
```
Если `ok=false`, значит нам вернулось нулевое значение типа.

### Различие поведение каналов

|          | unbuff., открытый                      | unbuff., закрытый           | buff. открытый         | buff., закрытый                                                    | `nil`                 |
| -------- | -------------------------------------- | --------------------------- | ---------------------- | ------------------------------------------------------------------ | --------------------- |
| Чтение   | Lock, пока не будет произведена запись | Возвращает нулевое значение | Lock, если буфер пуст  | Возвращает значение из буфера. Если пуст, то нулевое значение типа | Бесконечное зависание |
| Запись   | Lock, пока не будет чтение             | **ПАНИКА**                  | Lock, если буфер полон | **ПАНИКА**                                                         | Бесконечное зависание |
| Закрытие | Работает                               | **ПАНИКА**                  | Работает               | **ПАНИКА**                                                         | **ПАНИКА**            |
## Оператор `select`
Оператор `select` похож на `switch`:
```go
select {
	case v := <- ch1:
	case v := <- ch2:
	case ch3 <- x:
	case <- ch4:
	default:
	
}
```
Каждая ветвь пытается прочитать или записать данные в канал. Если это возможно, то выполняет чтение или запись и тело `case`. Если же выполняет чтение или запись в канал в разных ветках, то выберется случайная из них
Преимущество `select` в том, что он позволяет избегать deadlock - это когда ни одна из горутин не может продолжить работу, так как ожидает действий от другой. 
При доступе к каналу в разных горутинах должен соблюдаться порядок. Пример дедлока:
```go
func main() {
    ch1 := make(chan int)
    ch2 := make(chan int)
    go func() {
        v1 := 1
        ch1 <- v1
        v2 := <-ch2
        fmt.Println(v1, v2)
    }()
    v1 := 2
    ch2 <- v1
    v2 := <-ch1
    fmt.Println(v1, v2)
}
```
Мы кладем в `ch1` значение. Канал небуферезированный, значит выполнение горутины остановиться, пока из этого канала не прочитают значение. Дальше в `ch2` тоже кладется значение и ситуация та же - пока из него не прочитают, будет лок. И все - обе горутины ждут действий друг от друга и не могут ничего сделать. Это можно поправить:
```go
    ch1 := make(chan int)
    ch2 := make(chan int)
    go func() {
        v1 := 1
        ch1 <- v1
        v2 := <-ch2
        fmt.Println(v1, v2)
    }()
    v1 := <-ch1
    v2 := 2
    ch2 <- v2
    fmt.Println(v1, v2)
```
Но лучше использовать `select`. Если мы обернем обращение к каналам в него, то дедлока не будет какой бы порядок не был:
```go
    ch1 := make(chan int)
    ch2 := make(chan int)
    go func() {
        v1 := 1
        ch1 <- v1
        v2 := <-ch2
        fmt.Println(v1, v2)
    }()
    v1 := 10
    var v2 int
    select {
    case ch2 <- v1:
    case v2 = <-ch1:
    }
    fmt.Println(v1, v2)
```
После записи в `ch1` мы перекинемся в `select`, где произойдет чтение из него и никакого дедлока не будет
Часто `select` работает с несколькими каналами, поэтому его помещают в бесконечный `for` (зач, я так и не понял)

## Принципы и паттерны конкурентного программирования

### Горутины и изменяющиеся переменные
Раньше (до 1.21 или до 1.22)в переменная цикла создавалась один раз и ссылалась на один адрес в памяти, поэтому такой код:
```go
    arr := []int{2, 4, 6, 8, 10}
    ch := make(chan int, len(arr))
    for _, v := range arr {
        go func() {
            ch <- v * 2
        }()
    }
    for i := 0; i < len(arr); i++ {
        fmt.Println(<-ch)
    }
```
Выдавал одинаковые значение 20, так как горутины не успевали начать выполняться, а цикл уже закончился и в памяти лежало последнее значение из слайса. Сейчас такого вроде нет, но вот пути решения этого: надо либо передавать значение как параметр, либо затенять переменную в горутине
### Учетка горутин (goroutine leak)
Утечка горутин - это когда горутина продолжает существовать, но не выполняет никаких действий
```go
func main() {
    ch := make(chan int)
    go func() {
        for {
            select {
            case val := <-ch:
                fmt.Println("Received:", val)
            }
        }
    }()
    ch <- 42
    close(ch)
}
```
После закрытия канала, горутина все равно будет ждать новых значений

### Паттерн на основе канала `done`
С помощью этого паттерна можно сказать горутине, что можно прекращать выполнение
```go
func searchData(s string, searchers []func(string) []string) []string {
    done := make(chan struct{})
    result := make(chan []string)
    for _, v := range searchers {
        go func(searcher func(string) []string) {
            select {
            case result <- searcher(s):
            case <-done:
            }
        }(v)
    }
    r := <-result
    close(done)
    return r
}
```
Канал `done` имеет тип `struct{}` так как нам не важны значения. В этой функции мы ждем результата самый быстрой функции `searcher`. Когда произойдет чтение из канала `result`, то потом произойдет закрытие канала, а чтение из закрытого канала вернет нулевое значение

### Прекращение выполнения горутины с помощью функции отмены
Можно возвращать замыкание, чтобы завершать горутины:
```go
func countToWithCancel(max int) (<-chan int, func()) {
    ch := make(chan int)
    done := make(chan struct{})
    cancel := func() {
        close(done)
    }
    go func() {
        for i := 0; i < max; i++ {
            select {
            case <-done:
                return
            default:
                ch <- i
            }
        }
        close(ch)
    }()
    return ch, cancel
}

func main() { 
	ch, cancel := countTo(10)
	for i := range ch {
		if i > 5 { break } 
		fmt.Println(i) 
	} 
	cancel() 
}
```

## Когда использовать буферизированные и не буферизированные каналы
Буферизированные каналы стоит использовать тогда, когда вы знаете кол-во запущенных горутин и хотите ограничить кол-во горутин, которые еще будут запущены, или хотите ограничить объем работы, стоящей в очереди на выполнение.
Например:
```go
func processChan(ch chan int) []int {
    const conc = 10
    res := make(chan int, conc)
    for i := 0; i < conc; i++ {
        go func() {
            v := <-ch
            res <- process(v)
        }()
    }
    var out []int
    for i := range res {
        out = append(out, i)
    }
    return out
}
```

