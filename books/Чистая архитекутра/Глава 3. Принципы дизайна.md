[[Чистая архитектура]]

Здесь речь идет о принципах SOLID

## Принцип единой ответственности (Srp)
SRP - *это принцип, который говорит нам, что у модуля должна быть только одна причина для изменения.*
Но это не совсем так. По сути это перефразированно от функция должна делать только одно. Но это не SRP. ПО изменяется для удовлетворения нужд пользователей и заинтересованных лиц. Они как раз и являются *той самой* причиной для изменения. То есть SRP - *модуль должен отвечать за одного пользователя или заинтересованного лица*. Но это тоже не очень точно. Потому что причины для изменений могут исходить от группы пользователей. Такую группу можно называть акторами (actors). Итого:
> ***SRP*** - модуль должен отвечать за одного и только одного актора 

Что такое модуль? Ну, например файл и исходным кодом. Или связанный набор функций и структур данных.
Рассмотрим признаки, когда SRP нарушается
### Признак 1. Непреднамеренное дублирование
Например у нас есть класс `Employee` из приложения платежной ведомости. У него три метода `calcPay`, `reportHours`, `save`
![[Pasted image 20240918125324.png]]*CFO - бухгалтерия, COO - работа с персоналом, CTO - админ БД*
Этот класс нарушает SRP, потому что три его метода отвечают за три разных актора:
- Реализация метода `calcPay` определяется бухгалтерией
- Реализация метода `reportHours` определяется отделом по работе с персоналом
- Реализация метода `save` определяется админом БД

Поместив кол этих трех методов в общий класс `Employee`, разработчики объединили всех акторов

 Например, методы `calcPay` и `reportHours` используют общий алгоритм расчета не сверхурочных. И разработчики поместили этот алгоритм в отдельную функцию
 ![[Pasted image 20240918125636.png]]

Теперь представим, что бухгалтерия решила изменить алгоритм расчета не сверхурочных. Сотрудники по работе с персоналом против такого, тк как время они используют для других целей. И разраб не заметил, что `regularHours` также вызывается в методе `reportHours`. По итогу измененный алгоритм получили те, кто так и хотели (бухгалтерия) и те, кто не хотели (работа с персоналом)

### Признак 2. Merge

### Решения
Существует много решений этой проблемы. Но каждое связано с перемещением функций в разные классы.
Наиболее очевидно разделить данные и функции на 3 класса
![[Pasted image 20240918130226.png]]
Недостаток такого решения - разработчик должен создавать 3 инстанса класса и следить за ними. Эта проблема решается применением шаблона проектирования Фасад (Facade)
![[Pasted image 20240918130404.png]]

В кратце - мы создаем фасад, который менеджит все остальные классы.

## Принцип открытости/закрытости (Ocp)

OCP (open close principle) - программные сущности должны быть открыты для расширения и закрыты для изменения
Иными словами, должна иметься возможность расширять поведение программных сущностей без их изменения. 

Например у нас есть финансовая сводка. Содержимое страницы прокручивается и отрицательные значения выводятся красным цветом. Нас попросили представить ту же информацию в виде отчета, распечатанного на черно-белом принтере. Отчет должен быть разбит на страницы, включать верхний и нижний колонтитулы. Отрицательные значения должны быть в круглых скобках.
Новый код придется писать, но нужно ли менять старый? В идеале - нет. Разделяя правильно сущности мы не будем переписывать старый код при добавлении изменений
![[Pasted image 20240918131135.png]]
Самое важное - это то, что для создания отчета есть 2 сущности: вычисление данных для отчета и его представление

### Принцы подстановки Барбары Лисков (Lsp)

***Принцип подстановки Барбары Лисков (LSP Liskov Subtitution Principle)*** - для создания ПО из взаимозаменяемых частей эти части должны соответствовать контракту, который позволяет заменять эти части.

Рассмотрим этот принцип на проблеме квадрат/прямоугольник
#### Проблема квадрат/прямоугольник
![[Pasted image 20240918131632.png]]
В этом примере класс `Square` неправильно определен как подтип класса `Rectangle`, так как высоту и ширину прямоугольника можно изменять независимо, а высоту и ширину квадрата можно изменять только вместе. 
```java
Rectanle r = ...
r.setW(5);
r.setH(2);
assert(r.area() == 10);
```
Если вместо `...` поставить `Square`, то assert упадет.
То есть наследуясь от какой-то сущности, мы не должны менять поведение оригинальной сущности

### Принцип разделения интерфейсов (Isp)
Принцип разделения интерфейсов (ISP - interface segregation principle) - избегать зависимости от того, что не используется
![[Pasted image 20240918132146.png]]
Есть несколько классов, которые пользуются операциями класса `OPS`. Допустим, `User1` использует только `op1`, `User2` только `op2`, `User3` только `op3`.
Предположим, что мы реализуем это на Java. Тогда код `User1` будет непреднамеренно зависим от `op2` и `op3`. Это значит, что при изменениях в `op2` нужно будет перекомпилировать все.
Это можно решить, разделив операции по интерфейсам
![[Pasted image 20240918132459.png]]

Теперь `User1` зависит от `U1Ops`, а не от `OPS`. 

#### ISP и язык
Очевидно, что описание выше зависит от языка. В языках со статическими типами, например Java, нужно создавать объявления, которые должны импортироваться к коду как-то иначе.
В языках с динамической типизацией подобные объявления отсутствуют в коде, так как определяются на этапе испольнения.

Этот факт ведет нас к заключению, что ISP является проблемой языка, а не архитектуры

#### ISP и архитектура
![[Pasted image 20240918132837.png]]
Например, в `D` есть функции, которые не используются в `F` и в `S`. Изменение этих функций в `D` вынудят нас заново разворачивать всю эту цепочку

### Принцип инверсии зависимости (Dip)
***Принцип инверсии зависимости (DIP dependency inversion principle)*** - код, реализующий высокоуровневую политику, не должен зависеть от кода, уровнем выше. Напротив, детали должны зависеть от политики.

Мы должны избегать зависимости от неустойчивых конкретных элементов системы. То есть от муделей, которые развиваются и часто меняются.

#### Стабильные абстракции
Зависимости должны быть от интерфейсов, так как они изменяются намного реже, чем конкретные реализации. Из этого следует:
- Не ссылайтесь на изменчивые конкретные классы. Ссылайтесь на абстрактные интерфейсы
- Не наследуйте изменчивые конкретные классы
- Не переопределяйте конкретные функции
- Никогда не ссылайтесь на имена конкретных и изменчивых сущностей

#### Фабрики
Чтобы соблюсти эти правила, нужно придумать способ создания изменчивых объектов. Для этого используется паттерн Абстрактная фабрика 
