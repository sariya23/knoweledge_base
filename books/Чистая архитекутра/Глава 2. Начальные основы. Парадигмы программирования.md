[[Чистая архитектура]]

## Обзор парадигм
#### Структурное программирование
Структурное программирование накладывает ограничения на прямую передачу управления

#### Объектно-ориентированное программирование
ООП накладывает ограничение на косвенную передачу управления

#### Функциональное программирование
Функциональное программирование накладывает ограничение на присваивание

#### Пища для ума
Как видно, каждая парадигма что-то *отнимает*. Она говорит не столько *что делать*, а *чего нельзя делать*

### Структурное программирование
Придумал это все очень умный мужик Дейсктра. Он капец умный, вот правда. По сути основал профессию *программист*

Что Дейсктра хотел сделать? Он хотел, чтобы программа состояла из доказуемых единиц, но с оператором goto это было невозможно. То есть по сути - функциональная декомпозиция.

Дейсктра сказал: "Тестирование показывает присутствие ошибок, а не их отсутствие". И это все в середине 20в! BOOM!
Высказывание выше делает написание ПО не мат. задачей, а наукой, так как мы убеждаемся в правильности, потерпев неудачу в попытке доказать неправильность.

Парадигма структурного программирования заставляет нас рекурсивно разбивать программы на множество мелких и доказуемых функций. В результате мы получаем возможность использовать тесты, чтобы попытаться доказать их неправильность. Если такие тесты терпят неудачу, тогда мы считаем функции достаточно правильными. Функциональная декомпозиция.

### ООП
А что такое ООП? Это комбинация данных и функций? Но это нельзя назвать точным, так как тогда `o.f()` - это что-то отличное от `f(o)`. Но это не так.
Может это "способ моделирования реального мира"? А нафига нам это? Чтобы сделать код ближе к реальному миру? Очень расплывчато.
А может быть это инкапсуляция, наследование, полиморфизм?  А вот тут надо подробнее углубиться

#### Инкапсуляция?
С помощью инкапсуляции есть возможность очертить круг связанных данных и функций. За пределами этого круга эти данные невидимы и доступны только некоторые функции. Но эта идея не уникальна для ООП. В языке C есть поддержка инкапсуляции, хотя он и не является ОО
point.h
```c
struct Point;
struct Point* makePoint(double x, double y);
double distance (struct Point *p1, struct Point *p2);
```
point.c
```c
#include "point.h"
#include "stdlib.h"
#include "math.h"

struct Point {
	double x, y;
};

struct Point* makepoint(double x, double y) {
	struct Point* p = malloc(sizeof(struct Point));
	p->x = x;
	p->y = y;
	return p;
}

double distance(struct Point* p1, struct Point* p2) {
	double dx = p1->x - p1->x;
	double dy = p1->y - p2->x;
	return sqrt(dx*dx+dy*dy)
}
```
Пользователи point.h не имеют доступа к членам структуры Point. Они могут вызвать функции `makePoint` и `distance`,  но не имеют никакого представления о реализации Point и функций для работы с ней.
Это пример поддержки инкапсуляции не в ОО языке.

В C++ появилась поддержка ООП и теперь по техническим причинам (чтобы иметь возможность определить размер экземпляра каждого класса) в заголовочном файле нужно определять переменные класса
point.h
```cpp
class Point {
public:
	Point(double x, double y);
	double distance (const Point& p) const;
private:
	double x;
	double y;
}
```
Теперь пользователи point.h знаю о переменных класса x и y. И инкапсуляция разрушилась
#### Наследование?
Языки ОО не улучшили инкапсуляцию, зато они дали наследование. По сути, наследование - это всего лишь повторное объявление группы переменных и функций в ограниченной области памяти. И... это тоже было в C. Не буду приводить пример, тк я почти в этих ваших СИ не понимаю. Просто такое было (стр 58-59). Но там капец сложно, даже для тех, кто пишет, так как много за чем следить надо.
То есть можно сказать, что некоторая разновидность наследования была и до языков ОО. Но это был больше хак, нежели фича. Сейчас же наследование реализуется для пользователя просто.

#### Полиморфизм
Был ли полиморфизм до ОО? Да
```c
#include <stdio.h>

void copy() {
	int c;
	while ((c=getchar()) != EOF) {
		putchar(c);
	}
}
```
Функция `getchar` читает из STDIN. Но какое устройство скрыто под STDIN? А какое устройство скрыто за `putchar` STDOUT? Эти функции являются *полиморфными* - их поведение не зависит от типа устройств. Это похоже на интерфейсы, но в C нет интерфейсов, тогда как оно все определяет откуда читать и куда писать?
Ответ прост: ОС UNIX требует, чтобы каждый i/o драйвер имел 5 функций: read, write, close, open, seek.
Структура FILE имеет 5 указателей на функции. Например так:
```
struct FILE {
	void (*open)(char* name, int mode);
	void (*close)();
	int (*read)();
	void (*write)(char);
	void (*seek)(long index, int mode);
}
```
И по сути `getchar` вызывает функцию, на которую ссылается указатель `read`, на которую ссылается STDIN
```c
int getchar() {
	return STDIN -> read();
}
```
И полиморфизм был уже, его просто сделали удобнее, чтобы не жонглировать указателями. 

Итог: ОО накладывает ограничение на косвенную передачу управления. Чтобы не помнить о каждой ячейке памяти, не забывать передавать указатель и тд.

#### Инверсия зависимости
До появление удобного механизма полиморфизма поток выполнения программы совпадал с зависимостями. ТО есть главная функция вызывала функции верхнего уровня, которые вызывали функции среднего уровня, которые вызывали функции нижнего уровня.
![[Pasted image 20240917214648.png]]


Но как только появился полиморфизм стало возможно делать так:
![[Pasted image 20240917214853.png]]
Во время выполнения интерфейсов не существует. Модуль HL1 просто вызывает F() внутри ML1. Но у нас поменялось направление зависимости. Это инверсия зависимостей.
Любую зависимость исходного кода можно инвертировать. Но нафига? Чтобы сделать независимыми модули
![[Pasted image 20240917215301.png]]

### Функциональное программирование
Рассмотрим программу, которая находит квадраты целых числе от 1 до 25
```java
public class Squint {
	public static void main(String args[]) {
		for (int i = 0; i < 25; i++) {
			System.out.println(i*i)
		}
	}
}
```
Вот как бы выглядела та же программа на языке Clojure 
```Clojure
(println ;
	(take 25 ;
		(map (fn [x] (*x x)) ;
			(range)));
```
В кратце, что происходит:
- функция `range` возвращает бесконечный список целых чисел от 0
- этот список передается в функцию `map`, в которой определена анонимная функция для вычисления квадрата
- список квадратов передается функции `take`, которая берет только первые 25 значений
- принт он и в Африке принт

Так где же тут функциональная парадигма? В программе на Java используется изменяемая переменная - переменная, состояние которой изменяется в ходе выполнения. Это переменная `i` цикла `for`. В программе на Clojure нет изменяемых переменных.

#### Неизменяемость и архитектура
Почему нас должно волновать - изменяется или нет переменная? Все состояние гонки и дедлоки как раз от того, что переменные изменяются. Если переменная не изменяется, то и блокировок не будет.  Сделать неизменность переменных реально, если есть бесконечная память. Но такого нет. Поэтому достигается это с помощью компромиссов

##### Ограничение изменяемости
Можно делить приложение на изменяемые и неизменяемые компоненты. Неизменяемые компоненты решают задачи чисто функциональным способом.

##### Регистрация событий 
Тут в дело вступают транзакции. Зачем нам при увеличении счета в банке менять именно переменную этого счета? Можно просто хранить список операций над этим счетом. Этот принцип называется регистрация событий (event sourcing) - это стратегия, согласно которой сохраняются транзакции, а не состояние. Когда требуется получить состояние, мы просто применяем все транзакции.

### Ответка хейтерам старых книг
Разработка программного обеспечения не является быстро развивающейся индустрией. Правила остаются теми же, какими они были в 1946, когда Алан Тьюринг написал первый код, который мог выполнить компьютер. Инструменты изменились, аппаратура тоже, но суть ПО осталась прежней