[[PostgreSQL. Основы языка SQL. Учебное пособие]]
## Значения по умолчанию и ограничение целостности
Есть несолько типов ограничения
### Ограничение `CHECK`
Есть два типа ограничений `CHECK`: на уровне атрибута и на уровне таблицы. 
```sql
-- Уровнь таблицы
id int,
check (id > 0)
```
```sql
-- Уровень атрибута
id int check(id > 0),
```
Разница только синтаксическая. У каждого ограничения есть имя. Его можно указать явно добавив ключевое слово `CONSTRAINT`
```sql
create table t 
(
	...
	mark numeric(1),
	CONSTRAINT valid_mark check(mark > 0)
)
```
Если не задавать имя, то оно создаться автоматически
### Ограничение `NOT NULL`
```sql
create table t (
	id int not null
)
```
```sql
create table t (
	id int 
	check (id is not null)
)
```

### Ограничение `UNIQUE`
Когда уникальность определяется по одному столбцу, то можно использовать ограничение на уровне атрибута
```sql
create table t (
	id int unique
)
```
Но с помощью ограничений на уровне таблицы можно создать уникальной по нескольким столбцам
```sql
create table t (
	id int,
	age int,
	unique(id, age)
)
```
*При добавлении ограничения уникальности автоматически создается индекс на основе B-дерева.*

### Первичные ключи
```sql
create table t (
	id int primary key
)
```
Как и в случае `unique` при ограничении на уровне таблицы можно создавать первичные ключи по нескольким полям
```sql
create table t (
	id int,
	age int
	primary key (id, age)
)
```
*При добавлении первичного ключа автоматически создается индекс на основе B-дерева*
В таблице может быть только один первичный ключ.
### Внешний ключ
Создание внешнего ключа на основе ограничения на уровне атрибута
```sql
create table t (
	book_id int references book (book_id)
)
```
Предложение `references` создает ограничение ссылочной целостности и указывает в качестве ссылочного ключа атрибут `book_id`
Можно определить внешний ключ в форме ограничения на уровне таблицы
```sql
create table t (
	book_id int
	foreign key (book_id) references book (book_id)
)
```

### Изменение и удаление данных в ссылаемой таблице
- Удаление связных строк. Тогда в ограничении нужно указать `ON DELETE CASCADE`. Тогда удалятся все записи, которые связаны с ссылающейся записью
- Запрет на удаление. Нужно добавить `ON DELETE RESTRICT` или `ON DELETE NO ACTION`
- Присваивание значение `NULL`. Тогда нужно указать `ON DELETE SET NULL`. Но не должно быть ограничения у записей `NOT NULL`
- Установка значения по умолчанию. Тогда нужно указать `ON DELETE SET DEFAULT`

## Модификация таблицы
Все изменения, такие как:
- Добавление колонок
- Удаление колонок
- Добавление/удаление ограничений
- И тд
Делаются с помощью команд `alter table`

## Представления
Можно сохранять какой-то запрос в представления:
```sql
create view view_name as <querry>;
```
Например:
```sql
create view seats_by_fare_cond as 
	select aircraft_code, fare_cond, count(*)
	from seats
	group by aircraft_code, fare_cond;
```
Теперь мы можем использовать этот запрос везде. Как будто это обычная таблица
```sql
select * from seats_by_fare_cond;
```
В отличии от таблиц, представление не содержит данных. При каждом обращении к представлению в команде `select` данные выбираются из таблиц, на основе которых это представление создано.
Также Postgres добавляет фразу `OR REPLACE`. Если представление уже есть, то можно его не удалять. Но при этом название колонок должны остаться такими же.
Также есть материализованные представления. 
```sql
create materialized view name as query;
```
Материализованное представление похоже на просто таблицу. Оно отличается от нее тем, что не только сохраняет данные, но также запоминает запрос, с помощью которого эти данные забрала
Чтобы сказать представлению, что данные нужно обновить, нужно выполнить:
```sql
refresh materialized view name;
```
Они позволяют оптимизировать запросы, так как выборка происходит единоразово