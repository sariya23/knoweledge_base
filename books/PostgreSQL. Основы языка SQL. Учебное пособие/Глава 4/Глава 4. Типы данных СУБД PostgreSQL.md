[[PostgreSQL. Основы языка SQL. Учебное пособие]]

## Числовые типы
### Целые
Целые числовые типы - `smallint`, `int`, `bigint`. Для них есть алиасы - `int2`, `int4`, `int8`. Число показывает размерность типа в байтах.

### Дробные
Числа фиксированной точности представлены двумя типами - `numeric` и `decimal`. Они идентичны.
Тип `numeric` состоит их двух частей - масштаб и точность. Масштаб определяет общее кол-во знаков, а точность - кол-во знаков после запятой. `numeric(6, 2)` - число с масштабом 6 и точностью 2. Если масштаб значения, которое нужно сохранить, превышает объявленный масштаб столбца, система округлит его до заданного количества цифр после точки. Этот тип реализует точные вычисления. Но из-за этого он много весит и замедляет работу.
Типы с плавающей запятой - `real` и `double precision`. Они реализованы как и в ЯП - то есть по стандарту `IEEE Stardart 754 for binary floatin-point arithmetic` и являются не точными

### Последовательные типы
`serial` - это последовательный тип. Он генерирует последовательность с авто инкрементом.
```sql
create table t (id serial)
```
Если это реализовывать самостоятельно, то нужно вручную создавать последовательность:
```sql
create sequence t_id;
create table t (
	id int not null
	default nextval('t_id')
);

alter sequence t_id owned by t.id;
```

## Строковые типы
Стандартные типы для строк - `char(n)` и `varchar(n)`. Где `n` - максимальное кол-во символов в строке. Отличие `char` от `varchar` в том, что если строка будет по длине меньше чем `n`, то в случае `char` она дополнится кол-во пробелов до `n`, а `varchar` останется такой какая есть
`text`- это тип, куда можно положить ОЧЕНЬ большую строку.

В Postgres есть row strings, которые создаются с помощью `$$`
```sql
select $$PGDAY'17$$;
```
Либо без сырых строк:
```sql
select 'PGDAY''17';
```
Также есть C-стиль:
```sql
select E'PGDAY\n17';
```

## Типы даты и времени

## Логический тип
Значения для поля `bool`, которые считаются как TRUE без преобразования типов: `TRUE`, `'t'`, `'true'`, `'y'`, `'yes'`, `'on'`, `'1'`. Для false тоже самое, только наоборот

## Массивы
Создание массива:
```sql
create table t (
	arr <TYPE>[]
)
```
Вставка:
```sql
insert into t values ('{1, 2, 3, 4}'::<TYPE>[])
```
Добавить в конец:
```sql
update t set arr = arr || 9;
update t set arr = array_append(arr, 9)
```
Вставка в начало:
```sql
update t set arr = array_prepend(1, arr)
```
Удаление по значению:
```sql
update t set arr = array_remove(arr, 9);
```
Нумерация начинается с единицы. Можно менять значение по индексу:
```sql
update t set arr[1] = 2, arr[2] = 3;
```
Срез массива:
```sql
update t set arr[1:2] = array[2, 3]
```
Оператор `@>` означает проверку, что в левом массиве есть все элементы правого массива
```sql
select * from t
where arr @> '{2, 9}'::int[];
```
Проверяем, что в нашем массиве есть и 2, и 9
Проверка пересечения значений массива:
```sql
select * from t
where arr && array[2, 5]
```
`array[2, 5]` и `'{2, 5}'::int[]` - одно и то же

## JSON
