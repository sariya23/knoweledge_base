[[System design]]

## Конфигурация из одного сервера
Поток запросов при конфигурации из одного сервера. На этом одном сервере располагаются и кэш, и БД, и приложение: все
![[Pasted image 20241202190603.png]]
Клиент идет на DNS сервер, чтобы получить IP по доменному имени, а дальше отсылает запрос на этот IP

## База данных
Когда пользователей становится больше, то нужно разделить БД и веб-приложение по разным серверам. Это позволит масштабировать их независимо
![[Pasted image 20241202190740.png]]
### Какую базу данных выбрать
БД бывают реляционными и нереляционными. 
С помощью SQL можно выполнять запросы к реляционным СУБД, выполняя соединения.
Не реляционные, ака NoSQL делятся на 4 категории: ключ-значение, графовые, столбцовые и документные. 
Обычно выбирают реляционные БД, так как они зарекомендовали себя. Но NoSQL БД можно выбрать в следующих случаях:
- Нужна низкая латентность (latency - задержка) приложения
- Данные не имеют связей или неструктурированны
- Нужна только сериализация и десериализция данных в json, xml и тд
- Нужно хранить ОГРОМНЫЕ объемы данных

## Горизонтальное и вертикальное масштабирование
Вертикальное масштабирование - увеличение мощности одного сервера
Горизонтальное масштабирование - увеличение инстансов серверов
![[Pasted image 20241202191311.png]]
У вертикального масштабирование есть ключевые недостатки:
- Предел наращивания
- Может создаться единая точка отказа

## Балансировщик нагрузки
Если у нас один сервер с веб приложением, то большое кол-во пользователей могут уронить его. И даже вертикальное масштабирование не поможет. Балансировщик нагрузки позволяет распределять нагрузку между веб серверами
![[Pasted image 20241202191522.png]]
Теперь клиент подключается не напрямую к серверу, а к балансировщику нагрузки, который уже определяет куда перенаправить трафик. Балансер обращается по внутренним адресам по соображениям безопасности.
Сейчас все выглядит хорошо. Но на слое данных по прежнему одна БД, которая может вылететь и балансер не спасет. Для решения проблемы этой проблемы используют *репликацию*
## Репликация БД
Репликация БД обычно происходит в режиме ведущий(master)-ведомый(slave). Роль ведущий БД играет оригинал (master), а копий - slave. 
Ведущая БД поддерживает только операции записи. Ведомые БД получают от ведущей копии содержимого и поддерживают только чтение. 
Чтение обычно происходит чаще, чем запись, поэтому slave БД больше, чем master
![[Pasted image 20241202192334.png]]
Если одна из БД перестанет работать, то
- Если есть только одна slave БД и она выйдет из строя, то операции чтения будут перенаправлены на master БД. Ну а потом чиним, чиним, чиним...
- Если из строя выйдет master БД, то операции записи будут перенаправлены на slave БД. Но часто чтобы превратить slave БД в master требуются доп усилия, так как в slave могут быть неактуальные данные. Также можно использовать архитектуру с несколькими master БД и циклическую репликацию.

![[Pasted image 20241202192838.png]]

Теперь пришло время улучшить время ответа и загрузки. Для этого нужно добавить уровенб кэша и разместить static в CDN

## Кэш
Кэш - это участок памяти, в который временно записывается результат тяжелый операции и часто используемые данные
### Уровень кэша
![[Pasted image 20241202193450.png]]
Эта стратегия называется кэшем сквозного сечения. Взаимодействовать с кэшем можно через API интерфейсы, но также если и готовые библиотеки для работы с кэшем.
### Аспекты использования кэша
- Кэш хранится в энергозависимой памяти, поэтому кэшировать нужно те данные, которые НЕ постоянные
- Также важно определиться с TTL данных в кэше. Если поставить слишком короткий TTL, то может быть очень часто обращение к БД и все + кэша уйдут, а если поставить слишком долгий, то мы можем отдавать неактуальные данные
- Может возникнуть несогласованность кэша и БД. Это произойдет в случае если мы кэшируем то, что часто записывается
- Единая точка отказа (SPOF), если мы используем один сервер для кэша, то он может стать SPOF
- Политика вытеснения. Когда кэш переполняется, то новые данные могут вытеснить старые. А как вытеснить - это и надо определить. Можно по LIFO, можно по LRU(last recently used)
## CDN
CDN - это сеть географически распределенных серверов, которая используется для доставки статический файлов, например изображения, js, html, css. Серверы CDN кэшируют их
Кэшировать можно и динамические данные. В зависимости от куки файлов, параметров и пути

Принцип работы CDN: когда пользователь заходит на сайт, то ближайший CDN доставляет ему статическое содержимое
![[Pasted image 20241202194446.png]]

Более подробный принцип работы CDN:
- Пользователь A отправляет запрос на получение изображения. Изображение может хранится либо на сервере, либо во внешних хранилищах, например s3
- Если в кэше CDN нет такого изображения, то он запрашивает его у сервера
- CDN получает изображение от источника вместе с заголовком TTL, который определяет сколько по времени хранить изображение на CDN
- CDN кэширует изображение и отравляет пользователю
- Пользователь Б отправляет запрос на получение того же изображения
- Если TTL еще не истек, то CDN отдает ему то самое закэщированное изображение
![[Pasted image 20241202195246.png]]
### Нюансы использования CDN
- Стоимость
- Также как и с кэшем тут нужно верно подобрать TTL
- Возможность сбоев. Нужно предусмотреть, что если CDN недоступен, то нужно дать клиенту возможность идти в другой источник

![[Pasted image 20241202195432.png]]

Теперь мы снизили время отклика и нагрузку на БД.
## Веб-уровень без сохранения состояния
Теперь нужно как-то горизонтально масштабировать сервера. Для этого из него нужно вынести состояние (например данные о сессии пользователя), в какое-то внешнее хранилище. Каждый веб сервер в кластере может запросить состояние из БД
### Архитектура с сохранением состояния
Если сервер хранит состояние, то он "помнит" данные клиента при разных запросах
![[Pasted image 20241202200454.png]]
Каждый запрос от каждого клиента должен направляться на "его" сервер. Это можно настроить в балансере, использовав липкие сеансы. Но такой подход делает добавление и удаление серверов затруднительным. Да и если сервер выйдет из строя, то что делать?
### Архитектура без сохранения состояния
![[Pasted image 20241202200659.png]]

Теперь у нас архитектура без сохранения состояния
![[Pasted image 20241202201003.png]]
Данные сеансы вынесены на слой данных

## Центры обработки данных (ЦОД)
![[Pasted image 20241202201228.png]]
Тут уже масштаб стран. Например, geoDNS можно перенаправлять челика из США в ЦОД1, а челика из Англии в ЦОД2
Для использования нескольких ЦОД нужно решить несколько тех. вопросов
- Перенаправление трафика
- Синхронизация данных
- Тесты и развертвывание
## Очередь сообщений
Очередь сообщений - это устойчивый компонент, который загружается в памяти и менеджит асинхронные сообщения.
Сервисы ввода, которые называются производители, создают сообщение и публикуют его в очереди. А серверы потребители принимают их и обрабатывают
Фишка в том, что производитель и потребитель независимы. Если недоступен производитель, то потребитель все равно можно обрабатывать сообщения из очереди. Если недоступен потребитель, то производитель все равно может класть сообщения в очередь
![[Pasted image 20241202201834.png]]
Производитель и потребитель могут масштабироваться независимо друг от друга
![[Pasted image 20241202201946.png]]
Теперь вообще выглядит люто и надежно. Или нет?

## Масштабирование БД
Тут все также. Вертикально и горизонтальное. Вертикальное такое же - накидываем мощность.

### Горизонтальное масштабирование
При горизонтальном мы добавляем серверов БД в кластер. Шардинг позволяет разбить огромные данные на маленькие кусочки. Все шарды имеют одну и ту же схему, но хранят уникальные данные

Пример сегментирования для сохранения пользователя. Сервер БД выбирается на основе ID пользователя. Этот ID пропускается через специальную хэш-функцию и значение, которое получилось на выходе, является ID сервера БД
![[Pasted image 20241202202322.png]]
Важно выбрать ключ шардинга так, чтобы данные распределялись равномерно.
Шардирование создает дополнительные трудности:
- Повторное сегментирование данных. Это может понадобиться тогда, когда либо один сегмент переполнен, либо другие шарды заполняются быстрее, чем остальные.
- Проблема знаменитостей. Слишком часто обращение к шарду может вызвать перегрузку. Например, что произойдет, если информация о Оксимироне, Noize MC и Басте окажется в одном шарде? Так еще и система у нас о музыке. Произойдет перегрузка шарда. Возможно, придется выделить по отдельному шарду на каждую знаменитость.
- Соединения и денормализация. После сегментирования становится сложно делать джойны между таблицами на разных серверах. Поэтому данные денормализуют, чтобы запрос можно было выполнить в пределах 1 таблицы

