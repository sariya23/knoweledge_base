[[Книги]]
Модеи данных - одна из важнейших частей разработки ПО , так как они влияют и на процесс разработки и общее представление решаемой проблемы
## Реляционная модель vs документоориентированная
### NoSQL
Основные причины внедрения NoSQL:
- Большие возможности масштабирования, чем у реляционных БД
- Специализированные запросные операции, плохо поддерживаемые реляционной моделью
- Свободные схемы моделей
### Использование идентификаторов
Преимущества использования идентификаторов вместо прямых значений в отдельной таблице
- единобразный стиль
- удобство модификации
- поддержка локализации. Ссылка остается та же, мы просто меняем выбираемую колонку
- Улучшенные возможности поиска
Преимущество айдишников состоит в том, что в силу отсутствия смысла для людей нет необходимости менять их в каких-либо случаях: айдишник останется тем же, даже если поменяется информация, на которую он ссылается
### Сетевая модель
Сетевая модель также известна под названием CODASYL. В сетевой модели у записи может быть несколько родителей, что позволило нормально моделировать связи m2m и m2o. Чтобы добраться до какой-то записи нужно было пройти по цепочкам ссылок, что называется путем доступа (access path)
### Реляционная модель
Реляционная модель - это таблицы и строки. Никаких лабиринтов структур, никаких запутанных путей доступа для просмотра данных. 
В реляционной модели оптимизитор запросов автоматически принимает решение об оптимальности выполнения, а не вручную (как в CODASYL). 
### Реляционные и документоориентированные БД сегодня
Преимущества документой модели в том, что у нее выше локальнсть (данные лежат в одном файле, не нужно ничего джойнить) и гибкость схемы. Но реляционная модель лучше справляется со связями m2m. 
Но нельзя сказать, что какая-то из моделей лучше. Реляционная методика расщепления данных на множество таблиц может сделать код запутанным. Но если нам нужны связи m2m и m2o, то документая модель справится плохо
### Гибкость схемы с документной модели
Большинство документных БД, а также реляционных БД с поддержкой json не навязывают схему. Документная БД - schema on read (структура данных неявна и их интерпритация происходит только при чтении), а реляционная БД - schema on write (схема данных проверяется при записи)

Когда нам нужно поменять схему в документной БД, то это делается просто. Например, мы хотим хранить ФИО в разных полях. Новые записи мы ведем с колонками Имя Фамилия Отчество, а старые оставляем как есть. Только в коде логики надо будет добавить проверку. Если же мы работаем с реляционной БД, то нужно катить миграции, а потом еще обновлять данные, а если данных много, то обновление будет долгим.

БД с подходом schema on read предпочтителен:
- существует много различных типов объектов, и нет смысла помещать каждый в отдельную таблицу
- *Структура данных определяется внешними системами, на которые мы не можем влиять* 
### Локальность данных и запросы
Документы хранят данные в виде непрерывных целых файлах - json, xml. Если приложению нужен часто доступ ко всему документу, то локальность дает определенные преимущества. 
## Языки запросов для данных
Языки бывают декларативными (что получить, а как - решай сам) и имеративными (разработчик пишет и что, и как). 
==Распараллелить императивный код очень непросто, так как в нем задается определенным порядок выполнения команд==
### Выполнение запросов с помощью MapReduce

> [!MapReduce]
> MapReduce - модель программирования для обработки больших объемов данных блоками на множестве машин

MapReduce основывается на функциях `map` и `reduce`. На них накладываются некоторые огарничения - они должны быть чистыми функциями. 
## Графоподобные модели
Если в приложении очень много связей, то стоит задуматься над графовыми СУБД. 
Графы состоят из
- Вершина или узел, или сущность
- Ребер или связей, или дуг
С помощью графов можно смоделировать практически все. Но вот распостраненные примеры:
- Социальные графы. Вершины - люди, а ребра - знакомства людей
- Веб-графы. Вершина - веб-страница, а ребра - ссылки на другие страницы
- Дороги и ЖД сети. Вершины - перекрестки, а ребра - дороги
### Графы свойств
В модели графов свойств каждая вершина состоит из:
- ID
- Множества исходящих ребер
- Множества входящих ребер
- Коллекции свойств (пар ключ-значение)
Каждое ребро состоит из:
- ID
- Начальная вершина
- Конечная вершина
- Коллекции свойств (пар ключ-значение)

Графы удобны возможностями расширения: по мере добавления в приложение новых свойств можно легко расширить граф с целью учесть изменения в структуре данных приложения.
### Модель тройных кортежей SPARQL
Эта модель практически эквивалента модели графов свойств и использует разные слова для описания тех же вещей. 
Вся информация хранится в форме 3-ех компонентных высказываний: (*субъект*, *предикат*, *объект*). Например, (Джим, любит, бананы). Субъект тройного картежа то же самое что и вершина графа