[[Высоконагруженные приложения]]

> [!Репликация]
> Репликация - хранение копий одних и тех же данных на разных машинах, соединенных с помощью сети

Причины использования репликации:
- Ради хранения данных географически ближе к клиенту
- Для обеспечения отказоустойчивости системы
- Для горизонтального масштабирования
## Ведущие и ведомые узлы
Одна их стратегий репликации - репликация с одним ведущим узлом. Один из узлов является мастером - нода, через которую происходит запись в слейвов (ведомые). 
![[Pasted image 20250817144138.png]]
Чтение происходит из ведомых узлов. 
### Синхронная и асинхронная репликация
При *синхронной* репликации ведущий узел ждет подтверждения от ведомых узлов и только после этого сообщает клиенту об успешности операции.
При *асинхронной* репликации мастер не ждет подтверждения.
Преимущество синхронной репликации - есть гарантия актуальности данных на мастере и ведомых узлах. Недостаток состоит в том, что если ведомый узел не отвечает, то операцию записи завершить не удастся. Поэтому делать все узлы синхронными *неразумно*. Часть узлов лучше делать асинхронной.
### Создание новых ведомых узлов
Нужно создавать новые ведомые узлы, чтобы расширять систему. Как гарантировать актуальность данных в новом узле? Просто скопировать данные не получится, так как клиенты постоянно что-то пишут. Блокировку можно сделать не всегда.
1. Сделать снимок состояния ведущего узла
2. Скопировать снимок на новый узел
3. Ведомый подключается к системе и запрашивает у ведущего узла изменения, прошедшие с момента снимка. 
### Перебои в обслуживании узлов
#### Отказ ведомого узла
Ничего сложного в отказе ведомого узла нет, так как после восстановления можно посмотреть в журнале метку последней транзакции, а потом запросить с этого момента времени у ведущего узла эти данные
#### Отказ ведущего узла
Тут чуть сложнее, так как нужно повысить в ранге один из ведомых узлов, настроить клиенты. Восстановление после отказа может происходить либо в ручном режиме, либо в автоматическом.
Восстановление после отказа наполнено большим количество потенциальных проблем:
- При использовании асинхронной репликации новый ведущий узел мог не получить все сообщения о записи от старого узла, так как он упал. Что делать с этими сообщениями? 
- Отбрасывание записей представляет опасность
- Сколько следует ждать, чтобы объявить ведущий узел упавшим?
### Журнали репликации
#### Операторная (логическая) репликация
В простейшем случае ведущий узел записывает в журнал операторы и отправляет их ведомым узлам (то есть напрямую запросы UPDARTE, INSERT и тд)
У этого подхода есть проблемы:
- В постгресе недерминированные функции (NOW, RAND и тд) будут выполнятся на мастере и отправлятся на реплики. В других СУБД может быть не так
- Есть есть столбцы с автоинкрементов, то на всех репликах они должны выполнятся в одном порядке
Но благодаря такому подходу можно не особо париться насчет разных версий СУБД на нодах, так как запросы и операторы вряд ли меняются
### Физическая репликация
При таком виде репликации на ноды отправляются прям файлы с данными. Тут уже одинаковость версий очень важна. 
## Проблемы задержки репликации
### Читаем свои же записи
Многие приложения позволяют отправить какие-то данные, а потом посмотреть, что было отправлено. В случае асинхронной репликации может возникнуть проблема. Если пользователь сразу посмотрит данные, то ему вернутся старые данные, так как его данные еще не успели дойти до реплики. Тут пригодится согласованность типа *чтение после записи*. Она гарантирует, что, перезапустив страницу, пользователь точно увидит свои изменения. Относительно других пользователей никаких обещаний нет. 
Как реализовать:
- Чтение измененных данных с ведущего узла
- Если юзер может редактировать почти все записи в приложени, то предыдущий подход окажется неэффекивным. Тогда нужно придумывать какие-то критерии  - например, таймстэмпы
### Монотонные чтения
Этот вид аномалии происходит при чтении с аминхронных ведомых узлов - пользователь может набулюдать движение в обратном направлении времени. При этой аномалии может происходить чтение из разных реплик разными пользоателями и они будут видеть разные данные, так как одна из реплик может немного запаздывать. 
### Согласованное префиксное чтение
При этой аномалии данные могут обрабатывать в разном порядке, что приводит к ощущению заглядывания в будущее. 
## Репликации с несколькими ведущими узлами
Этот вид репликации очень сложен и нужно несколько раз подумать перед тем, как его реализовывать. Возникает куча проблем с решением конфликтов и достижением согласованного состояния. 
## Репликация без ведущего узла
