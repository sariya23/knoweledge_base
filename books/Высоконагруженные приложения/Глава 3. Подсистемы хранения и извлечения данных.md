[[Высоконагруженные приложения]]
## Базовые структуры данных БД
Самой простой БД можно назвать файл, который хранит последовательно пары ключ-значение. Это будет *[^1]журнал*, куда новые данные только дописывается, а старые помечаются как недействительные (tonbstone). 
Поиск не очень будет оптимален, так как нужно будет перебрать в худшем случае все записи (`O(n)`).  Чтобы поиск сделать более оптимизированным нужно использовать дополнительные структуры данных - *индекс*
Индекс - дополнительная структура. На ее поддержку тратятся ресурсы, особенно при записи, так как индекс тоже приходится обновлять при записи данных.
### Хэш-индексы
Самый простой тип индексирование - индексы пар ключ-значение. Этот индекс основан на хэш мапе. 
Предположим, что хранилище работает только путем добавления в конец файла новых данных. Тогда самой простой стратегией хэширования будет хранения в памяти хэш мапы. Ключ в этой мапе обозначает смещение относительно начала файла. При поиске значения мы находим адрес и прыгаем к нужному месту.
Такой подход простой, но он практически так и работает в NoSQL СУБД Riak (подсистема Bitcask). 
Такая подсистема хорошо работает, когда много операций чтения и записи, но уникальных ключей немного. 
Есть проблема конечного места на диске. Решается они делением журанала на сегменты. Когда сегмент исчерпал свою память, он закрывается и запись идет в новый файл. Затем выполняется *уплотнение* сегментов - для дублирующихся ключей оставляется только последнее добавленное значение. После уплотноненные сегменты можно слить еще освободив место. Это все выполняется в фоновом режиме
#### Нюансы подхода
- CSV-файл так себе решенние. Лучше бинарный формат
- Удаление записей происходит путем пометки их спец строкой
- При восстановлении после сбоя вся информация будет утерена (так как все хранится в памяти)
- Недописанные записи. При сбое при записе будет недописанная запись
- Управление конкурентным доступом. 
Но почему нельзя обновлять записи на месте? Вот несколько причин:
- Добавление в конец файла и слияние сегментов - последовательные операции, которые в большинстве случаев выполняются быстрее рандомного доступа
- Конкурентный доступ в таком случае проще
#### Ограничения подхода
- Хэш мапа должна помещаться в памяти. Можно держать ее и на диске, но высокой скорости тогда ожидать не надо
- Запросы по диапазону неэффективны, только по точному сравнению
### SS-таблицы и LSM-деревья
SS-таблицы основаны на индексной хэш-таблице. Отличие в том, что данные хранятся в отсортированном виде, что позволяет:
- Возможен поиск по диапазону, мы можем не знать точного положения, но можем знать между кем находится искомый ключ
- Более эффективное слияние сегментов
- Возможна группировка сегментов для дальнейшего сжатия (по диапазонам)
Несколько SS-таблиц объединяются в LSM-деревья
### B-деревья
Это наиболее распостраненная индексная структура. Данные в нем также отсортированы по ключу, что позволяется эффективно выполнять поиск по значению и диапазону. Они более оптимизированы для поиска. 
Дерево гарантируется, что оно будет сбалансированным. 
Для обеспечения отказоустойчивости добавляют дополнительную структуру WAL (write ahead log, журнал упреждающей записи). Этот файл нужен только для добавления, в него пишутся данные перед добавлением в B tree. Этот файл помогает восстановить дерево после сбоя.
#### Апгрейды B-дерева
- Вместо WAL можно копировать данные при записи
- Можно экономить место на диске, храня не весь ключ, а только его сокращенный вариант
- Могут добавляться дополнительные указатели, например, на листы деревьев того же уровня, чтобы просматривать ключи без возврата к родительским страницам
## Обработка транзакций или аналитика
Основные паттерны использования БД - найти по индексу быстро несколько значений и вернуть их юзеру. За счет такой интерактивности такой паттер получил название OLTP (online transaction processing)
Но БД стали использоваться и для аналитики, где нужно просматривать огромное количество записей, читай в каждой только несколько столбцов и вычислять агрегатные функции (сумма, количетсов, среднее). Такой паттерн называется OLAP (online analytical processing). 
### Data warehouse
Data warehouse - это отдельна система из прцоессов и БД, которая используется для аналитики. Они могут в нее ходить и получать данные из разных OLTP баз и не нагружать их. 
Данные попадают в DWH через процессы ETL
![[Pasted image 20250812194432.png]]

### Звезда и снежинка
DWH может быть спроектировано моделью Звезда. 
![[Pasted image 20250812194609.png]]
В центре схемы - таблица фактов. В каждой строке отображается событие. А в таблице измерений хранятся подробности и уточнения этого события. 
Схема Снежинка имеет ту же логику, просто у каждого измерения могут быть еще подизмерения.
## Столбцовые хранилища
Если в таблице фактов содержатся триллионы строк и петабайты данных, эффективное хранение и выполнение запросов становится очень проблематичным. 
Стандартный запрос аналитика обращается к 4-5 столбцам из ста. Но большинство OLTP БД данные хранятся построчно: строки хранятся друг за другом. Идея столбцовых хранилищ в том, чтобы хранить рядом значения не из одной строки, а из одного столбца. 
![[Pasted image 20250812194957.png]]
### Сжатие столбцов
Столбцовые хранилища очень хорошо сжимаются. Например, методом битовой карты
![[Pasted image 20250812195041.png]]
Также столбцовые БД могут эффиктивно использовать циклсы CPU. Сжатие столбцов позволяет поместить в том же обьеме L1 кэша больше строк для одного столбца. 
### Кубы данных
OLAP-куб представляет собой сетку сводных показателей
![[Pasted image 20250812195405.png]]


[^1]: Последовательность записей только для добавления данных в конец
