[[100 ошибок в Go и как их избежать]]

Контекст - это токен отмены, как в cantok. Через него мы можем задавать дедлайн для некоторого действия, отменять по какому-то условию и передавать значения

## Deadline
`ContextWithDeadline` указывает на какой-то момент времени, через которое текущая деятельность должна быть отменена.
Например, мы должны сообщать координаты самолета каждые 4 секунды
```go
type publishHandler struct {
	pub publisher
}

func (h publishHandler) publishPosition(pos flight.Position) error {
	// Создаем контекст, который ждем 4 сек.
	ctx, cancel := context.WithTimeout(context.Background(), 4 * time.Second)
	defer cancel()
	// Передаем контекст 
	return h.pub.Publish(ctx, pos)
}
```
Смысл вызова `cancel` в `defer` в том, что конекст с дедлайном внутри себя создает горутину, которая будет храниться в памяти 4 секунды или до тех пор, пока не будет вызвана `cancel`. Это значит, что вызов `cancel` в `defer` при выходе из род. функции отменит контекст, а горутина остановится. Эта мера предосторожности, чтобы при возвращении мы не оставили в памяти сохраненные объекты.

## Сигнал отмены
Например, мы хотим написать функцию, которая создает файловый монитор до тех пор, пока контекст станет неактуальным или отменится. При выходе из `main` мы хотим, чтобы дескриптор файла закрылся корректно. 
```go
func main() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	go func() {
		CreateFileWatcher(ctx, "foo.txt")
	}()
}
```

## Значения контекстов
Через контекст можно передавать значения. Это полезно при работе с middleware или тогда, когда функция уже принимает контекст и принимает какое-то значение, которое должно быть общим для других подфункций. Так вот это значение может быть слишком агрессивным (invaise), чтобы мыть параметром. Тут и приходит на помощь контекст со значением
```go
ctx := context.WithValue(parentCtx, "key", "value")
```
Лучшей практикой при работе с контекстом значений является определение ключа пользовательским типом, чтобы не было коллизий:
```go
type key string
const myCustomKey key = "key"
func f(ctx context.Context) {
	ctx := context.WithValue(ctx, myCustomKey, "foo")
}
```

## Перехват отмены контекста
У типа `context.Context` есть метод `Done`, который возвращает односторонний канал уведомлений (`<- cnah struct{}{}`). Этот канал закрывается, когда работа, связанная с контекстом, должна быть отменена. Например:
- Канал `Done`, связанный с контекстом, созданным с помощью `context.WithCancel`, закрывается при вызове функции `cancel`
- Канал `Done`, связанный с контекстом, созданным с помощью `context.WithDeadline`, закрывается по истечении крайнего срока

Также есть метод `Err`, который возвращает `nil`, если канал `Done` еще открыт. Иначе возвращается ненулевая ошибка с причиной, почему канал `Done` еще не был закрыт. Например:
- ошибка `context.Canceled`, если канал отменен
- ошибка `context.DeadlineExceeded`, если крайний срок действия контекста прошел.
