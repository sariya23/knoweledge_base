[[100 ошибок в Go и как их избежать]]

Время выполнения рабочей нагрузки ограничено одним из след. факторов:
- Тактовой частотой/скоростью работы CPU. Например, это главный фактор при выполнении алгоритма сортировки слиянием. CPU-boud
- Скоростью работы ввода/вывода. Например, это главный фактор при выполнении вызова REST или запроса к БД. I/O-bound
- Объем доступной памяти. Memory-bound

Предположим есть такая функция:
```go
fucn read(r io.Reader) (int, error) {
	count := 0
	for {
		b := make([]byte, 1024)
		_, err := r.Read(b)
		if err != nil {
			if err != io.EOF {
				break
			}
			return 0, err	
		}
		count += taks(b)
	}
	return count, nil
}
```
Что, если мы хотим выполнять задачи конкурентно? Для этого можно воспользоваться паттерном Worker Pool. Для это необходимо создать воркеров. И у нас должен быть определен пул этих воркеров.
Но как определить, сколько воркеров должно быть в пуле? Если рабочая нагрузка I/O-bound, то кол-во воркеров определяется внешней системой. Если рабочая нагрузка CPU-bound, то рекомендуется полагаться на `GPMAXPROCS` - переменную, которая устанавливает кол-во потоков ОС, выделенных для выполнения горутин 

Есть еще функция  `runtime.NumCPU()`, которая возвращает кол-во логических ядер CPU. Ее отличие от `runtime.GOMAXPROCS()` в том, что этот параметр может быть изменен и может быть меньше, чем кол-во логических ядер. 