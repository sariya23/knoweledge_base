[[100 ошибок в Go и как их избежать]]

## Планирование в Go
*Поток* - это наименьшая единица обработки, которую может выполнять ОС. Если процесс хочет выполнить несколько действий одновременно, он запускается несколько потоков.

Потоки могут быть:
- *конкурентными*: два или более потока могут запускаться, выполняться и завершаться в перекрывающиеся периоды времени - как поток бариста и поток кофемашины в пред. примере 
- *Параллельными*: одна и та же задача может выполняться несколько раз одновременно

ОС отвечает за оптимальное планирование процессов потоков, чтобы:
- все потоки могли использовать процессорное время, не слишком долго ожидая своей очереди
- рабочая нагрузка распределялась между различными ядрами процессора максимально равномерно

Ядро процессора выполняет различные потоки. Когда оно переключается с одного потока на другой, выполняется операция *переключение контекста*. Переключение контекста считается дорогостоящей операцией, так как ОС нужно сохранить текущее состояние выполнения перед переключением

В Go нет потоков - тут горутины. Горутина занимает 2Кбайт, тогда как поток в среднем 2Мбайт. 

Переменная `GOMAXPROCS` определяет передел количества потоков, отвечающих за одновременное исполнение кода пользовательского уровня.

У горутины есть 3 состояния:
- исполнение (executing) - на потоке назначено исполнение горутины, и входящие в нее инструкции выполняются
- готовность к выполнению (runnable) - горутина ожидает перехода в состояние выполнения
- ожидание (waiting) - горутина остановлена и ожидает завершения чего-либо, например, системного вызова или операции синхронизации

Что происходит, когда горутина создана, но еще не может быть выполнена, например, все остальные потоки уже выполняют горутины? Тогда среда Go поставит эту горутину в очередь. Есть 2 типа очереди. По одной локальной очереди для каждого процессора и глобальная очередь, которая ориентирована на выполнения на всех P

![[Pasted image 20240907172553.png]]

Мы видим 5 потоков, тогда как GOMAXPROCS имеет значение 4. При необходимости среда выполнения может создавать больше потоков ОС

На рисунке процессоры P0, P1 и P3 заняты выполнением горутин. Но P2 простаивает, так как в потоке нет горутин для выполнения. Это не очень хорошо, так как 6 горутин готовы к выполнению. Как среда Go справляется с этим?
Реализация планирования на псевдокоде:
```go
runtime.schedule() {
	// Только 1/61 от всего времени, проверка глобальной очереди выполнения
	// на наличие горутин.
	// Если ничего не найдено, проверка локальной очереди
	// Если ничего не найдено, попытка украть у других процессоров.
	//    Если опять ничего не найдено, проверка глобальной очереди.
	//    Если ничего не найдено - опрос сети.
}
```
При каждом 61-ом выполнении планировщик будет проверять глобальную очередь. Если нет, то идет проверка локальной очереди. Если обе пусты, то планировщик попытается украсть горутину из других локальных очередй. Этот принцип называется work stealing. 

Начиная с версии 1.14 планировщик стал вытесняющим (preemptible). Горутина выполняется в течение некоторого заданного отрезка времени (10 мс), она будет помечена как вытесняемая и может быть контекстно отключена и заменена другой горутиной. 

## Параллельная сортировка слиянием
Конкурентность не всегда быстрее. Рассмотрим линейный алгоритм сортировки слиянием:
```go
func seqMergeSort(s []int) {
	if len(s) <= 1 {
		return
	}
	middle := len(s) / 2
	seqMergeSort(s[:middle])
	seqMergeSort(s[middle:])
	merge(s, middle)
}
```
Мы можем распределить нагрузку между ядрами, запустив каждую операцию `seqMergeSort` в другой горутине:
```go
func parallelMergeSort(s []int) {
	if len(s) <= 1 {
		return
	}
	middle := len(s) / 2
	var wg sync.WaitGroup
	wg.Add(2)
	go func() {
		defer wg.Done()
		parallelMergeSort(s[:middle])
	}()
	go func() {
		defer wg.Done()
		parallelMergeSort(s[middle:])
	}
	wg.Wait()
	merge(s, middle)
	
}
```
Если запустить бенчармарки и сравнить скорость работы этих 2 алгоритмов на 10000 элементах, то получится, то последовательная версия быстрее.
Так происходит, потому что доходя до 128 элементов или 256 (да маленьких значений) затраты на создание горутины намного выше, чем прямое выполнение.

Можно определить порог, после которого деление будет выполнятся последовательно:
```go
const max = 2048
func parallelMergeSort(s []int) {
	if len(s) <= 1 {
		return 
	}
	if len(s) <= max {
		seqMergeSort(s)
	} else {
		mid := len(s) / 2
		var wg sync.WaitGroup
		wg.Add(2)
		go func() {
			defer wg.Done()
			parallelMergeSort(s[:mid])
		}()
		go func() {
			defer wg.Donw()
			parallelMergeSort(s[mid:])
		}()
		wg.Wait()
		merge(s,  mid)
	}
}
```
Такая реализация быстрее линейной примерно на 40%