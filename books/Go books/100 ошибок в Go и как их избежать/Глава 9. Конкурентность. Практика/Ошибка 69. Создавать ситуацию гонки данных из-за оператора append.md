[[100 ошибок в Go и как их избежать]]

Рассмотрим пример:
```go
s := make([]int, 1)
go func() {
	s1 := append(s, 1)
	fmt.Println(s1)
}()
go func() {
	s2 := append(s, 1)
	fmt.Println(s2)
}()
```
Есть ли тут гонка данных? НЕТ! Изначально срез создается с емкостью и длиной 1. А как мы помним, если попытаться добавить новый элемент в заполненный (len=cap) срез, то среда создаст новую область в памяти и скопирует туда все старые элементы + новый. В каждой горутине будет создан новый участок в памяти и добавление будет в новый срез. Поэтому оператор `append` не изменяется массив, поэтому и гонки данных не будет.
Но, если мы сделаем так:
```go
s := make([]int, 0, 1)
```
То гонка данных будет, так как горутины  будут конкурировать за этот 1 свободный слот в памяти. 
Как решать эту проблему? Создавать копию среза в горутине, чтобы они работали с независимыми участками памяти:
```go
s := make([]int, 0, 1)
go func() {
	sCopy := make([]int, len(s), cap(s))
	sopy(sCopy, s)
	s1 := append(sCopy, 1)
}
```

Оператор `append` не всегда приводит к гонке данных. Но не должно быть разницы в поведении в зависимости заполнен срез или нет. 