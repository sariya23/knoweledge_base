[[100 ошибок в Go и как их избежать]]

## Тело HTTP
При отправке GET запроса нам возвращается тело ответа:
```go
resp, err := h.client.Get(h.url)
if err != nil {
	return "", err
}
body, err := io.ReadAll(resp.Body)
if err != nil {
	return "", err
}
return string(body), nil
```
Здесь происходит утечка ресурсов. `resp` - это `*http.Response`. У него есть поле `Body` `io.ReadCloser`. Это тело должно быть закрыто, если `http.Get` не возвращает ошибку. Проще всего это сделать через `defer`
```go
defer func() {
	err := resp.Body.Close()
	if err != nil {
		// ...
	}
}()
```
Тело ответа должно быть закрыто независимо о того, читаем мы его или нет. Например, если нам интересует только код ответа, то тело все равно надо закрыть
```go
resp, err := h.client.Post(h.url, "application/json", body)
if err != nil {
	return 0, err
}
defer func() {
	err := resp.Body.Close()
	if err != nil {
		log.Printf()
	}
}()
return resp.StatusCode, nil
```
Когда мы закрываем тело, поведение различается в зависимости от того, прочитано что-то из него или нет
- Если мы закроем тело без чтения, HTTP-транспорт может закрыть соединение
- Если мы закроем тело после чтения HTTP-транспорт не закроет соединение, поэтому его можно будет использовать далее

Если нам нужен только статус ответа, но мы также хотим повторно использовать соединение , то тело можно прочитать
```go
resp, err := h.client.Post(h.url, "application/json", body)
if err != nil {
	return 0, err
}
// закрытие тела
_, _ = io.Copy(io.Discard, resp.Body)
return resp.StatusCode, nil
```
В этом примере мы читаем тело только для того, чтобы сохранить соединение. Также вместе `io.ReadAll` мы используем `io.Copy` к `io.Discard`. Этот код читает тело, но никак не копирует его, игнорируя его. Это эффективнее, чем `io.ReadAll`

## sql.Rows
`sql.Rows` - это структура, используемая в качестве результате SQL-запроса. Эта структура реализует `io.Closer`, поэтому ее тоже нужно закрывать. Если строки не закрыть, то произойдет утечка соединения, которая не позволит вернуть это соединение в пул соединений.
```go
rows, err := db.Query("")
if err != nil {
	return err
}
defer fucn() {
	if err := rows.Close(); err != nil {
		log.Printf()
	}
}()
// Использование строк
```
## os.File
`os.File` представляет дескриптор открытого файла. Он также должен быть закрыт в конце. 
