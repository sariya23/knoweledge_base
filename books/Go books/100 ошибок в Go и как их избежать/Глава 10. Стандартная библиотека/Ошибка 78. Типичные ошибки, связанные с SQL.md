[[100 ошибок в Go и как их избежать]]

## Не знать, что sql.Open не всегда устанавливает соединение с БД
`sql.Open` не всегда устанавливает соединение с БД. Это даже написано в доке. Поведение зависит от драйвера SQL. Оно может быть ленивым, то есть не сразу, либо сразу. Чтобы убедится, что подключиться к БД действительно можно, нужно после `sql.Open` использовать `db.Ping`. Этот метод устанавливает соединение и поэтому по нему можно убедиться, что источник доступен
```go
db, err := sql.Open("mysql", dsn)
if err != nil {
	return err
}
if err := db.Ping(); err != nil {
	return err
}
```
## Забывать о пуле соединений
Функция `sql.Open` возвращает структуру `*sql.DB` и она хранит не одно какое-то соединение, а пул таких соединений.
У соединения в пуле может быть 2 состояния:
- Используется
- Простаивает
Создание пула делает доступным 4 параметра конфигурации пула:
- `SetMaxOpenCons` - максимальное кол-во открытых подключений. По умолчанию `unlimited`.  В проде лучше задавать.
- `SetMaxIdleCons` - максимальные кол-во неактивных соединений. По умл. 2.  Следует увеличивать, если приложение генерирует значительное кол-во одновременных запросов. Иначе могут быть частые повторные подключения.
- `SetConnMaxIdleTime` - максимальное кол-во времени, в течение которого соединение может простаивать, прежде чем будет закрыто. По умл. `unlimited`. Стоит менять, если приложение может столкнуться со всплеском запросов.
- `SetConnMaxLifetime` - максимальное кол-во времени, в течение которого соединение можно оставаться открытым, прежде чем будет закрыто. По умл. `unlimited`. Стоит менять, когда БД работает в режиме балансировки
## Не использовать подготовленные операторы
Подготовленный оператор полезен для частых одних и тех же запросов. Преимущества:
- Эффективность. Оператор не нужно перекомпилировать. Компиляция - синтаксический анализ + оптимизация + трансляция
- Безопасность. Снижает риск sql-инъекций

Чтобы использовать его нужно вызывать метод `Prepare`, а не `Query`
```go
stmt, err := db.Prepare("select * from order where id = ?")
if err != nil {
	return err
}
rows, err := stmt.Query(id)
```
## Неправильная обработка нулевых значений
Есть функция, которая получает данные о возрасте и депортаменте сотрудника:
```go
rows, err := db.Query("select ....")
if err != nil {
	return nil
}
var (
	dep string
	age int
)
for rows.Next() {
	err := rows.Scan(&dep, &age)
	if err != nil {
		return err
	}
}
```
Если значения отдела будет `NULL`, то этот код выдаст ошибку. Так как тип у `dep` `string`. 
Как это решить? 
Можно поменять тип `dep` на указательный. Но есть более элегантный подход - использовать тип `sql.NullXXX`, например, `sql.NullString`. 
`sql.NullString` - обертка поверх строк. Она содержит два поля: `String` содержит строковое значение, `Valid`  сообщает, не является ли значение строки `NULL`. Для каждого базового типа есть такая обертка. Лучше использовать такой подход, так как он более явно выражает намерения (Расс Кокс)
## Не обрабатывать ошибки итерации строк
Рассмотрим функцию, где неправильно реализуется обработка ошибок при итерации строк:
```go
rows, err := db.queryContext(ctx, "select....", id)
if err != nil {
	return err
}

defer func() {
	err := rows.Close()
	if err != nil {
		log.Printf("...")
	}
}()
var (
	dep string
	age int
)

for rows.Next() {
	err := rows.Scan(&dep, &age)
	if err != nil {
		return "", 0, err
	}
}
return dep, age, nil
```
Здесь мы обрабатываем 3 ошибки: при выполнении запроса, закрытии строк и сканирования строки. Но также нужно помнить, что цикл `for rows.Next() {}` может прерваться, когда больше нет никаких строк или ***когда возникает ошибка при подготовке след. строки***. После выполнения каждой итерации по строке мы должны вызывать `rows.Err`, что различать эти 2 случая:
```go
for rows.Next() {
	// ...
	if err := rows.Err(); err != nil {
		return "", 0, err
	}
	// ...
}
```