[[100 ошибок в Go и как их избежать]]

## Неожиданное поведение из-за встраивания типов
Создадим структуру и встроим в нее `time.Time`
```go
type Event {
	ID int
	time.Time
}
```
Что произойдет, если мы маршализуем его в JSON?
```go
event := Event{
	ID: 1234,
	Time: time.Now(),
}
b, err := json.Marshal(event)
fmt.Print(string(b))
```
Мы получим примерное это:
```
"2021-10-10T12:23:45"
```
Куда делся `ID` и `1234`? Здесь важно 2 момента.

Во-первых, если встроенный тип реализует интерфейс, структура, содержащая встроенное поле, также будет реализовывать этот интерфейс. Во-вторых, мы можем изменить поведение маршалинга по умолчанию, заставив тип реализовывать интерфейс `json.Marshaler`. 
```go
type Marshaler interface {
	MarshalJSON() ([]byte, error)
}
```
Пример:
```go
type foo struct{}
func (foo) MarshalJSON() ([]byte, error) {
	return []byte("foo"), nil
}

func main() {
	b, err := json.Marshal(foo{})
	if err != nil {
		panic(err)
	}
	fmt.Println(string(b)) // foo
}
```
Выяснив это, можно понять, куда пропал `ID`. `time.Time` реализует интерфейс `json.Marshaler`. Так как `time.Time` встроен в `Event`, то компилятор продвигает его методы. Поэтому `Even` также реализует `json.Marshaler`.
Эту проблему можно решить 2-мя способами. Первый - не использовать встраивание. Второй - реализовать `json.Marshaler` для `Event`
```go
func (e Event) MarshalJSON() ([]byte, error) {
	return json.Marshal(
		struct{
			ID int
			Time time.Time
		} {
			ID: e.ID,
			Time: e.Time,
		},
	)
}
```

## JSON и монотонные часы

*Этот подход также используется для сравнения gRPC структур*

В ОС есть два типа часов: настольные, которые показывают текущее время и монотонные. Настенные могут быть изменены в зависимости от локации или в ручную. Монотонные же часы гарантируют, что время движется только вперед и без скачков.

Создадим структуру с полем времени
```go
type Event struct {
	Time time.Time
}
```
Затем маршализуем и демаршализуем ее
```go
t := time.Now() 
event1 := Event{
	Time: t
}

b, err := json.Marshal(event1)
var event2 Event
err := json.Unmarshal(b, &event2)
fnt.Print(event1 == event2)
```
Нам выведется `fasle`. Почему? Посмотрим, что лежит в каждой из них
```go
2024-09-19 18:35:32.067528717 +0300 MSK m=+0.000067069
2024-09-19 18:35:32.067528717 +0300 MSK
```
Почему вывод одинаковый, кроме части `m=+0.000067069`

В Go вместо разделения двух часов на два разных API `time.Time` может содержать как настенные, так и монотонные часы
Когда мы получаем время с помощью `time.Now()` возвращается 2 типа часов
```
2021-01-10 17:13:08.852061 +0100 CET m=+0.000338660 
Wall time									Monotonic time
```
Когда же мы демаршализуем поле `time.Time` оно не содержит монотонного времени. Как решить эту проблему?
Можно использовать метод `Equal`, которые игнориурет монотонное время
```go
event1.Time.Equal(event2.Time)
```
Но тогда не затрагиваются другие поля.
Второй вариант - это использовать метод `Truncate`. Этот метод возвращает округленный в меньшую сторону до кратного заданной длительности результат значения `time.Time`. Можно указать нулевую продолжительнность и тогда монотонное время откинется
```go
t := time.Now()
event1 := Event{
	Time: t.Truncate(0),
}
```

## Карта и тип any
При демаршалинге мы можем иметь дело с картой, а не структурой. Важно помнить о том, что любое числовое значение будет сохранено в мапу как `float64`. Даже если в json стоит просто `1`.