[[100 ошибок в Go и как их избежать]]

Аргументы отложенной функции вычисляются СРАЗУ. Рассмотрим пример:
```go
func main() {
    f(1)
}

func f(i int) int {
    var res string
    defer notify(res)
    if i == 0 {
        res = "zero"
    } else if i == 1 {
        res = "one"
    } else {
        res = "qwe"
    }
    return i
}

func notify(i string) {
    fmt.Println(i)
}
```
Этот код всегда будет выводить пустую строку. Это происходит, так как аргумент отложенной функции `notify` вычисляется сразу, а на момент вычисления в `res` лежит пустая строка.
Решить эту проблему можно двумя способами. Первый сводится к тому, чтобы отложенная функция принимала указатель
```go
    var res string
    defer notify(&res)
```
Это работает, так как указатель остается неизменным на протяжении выполнения, значение может меняться, но адрес нет (есть исключения). Но для этого нужно менять сигнатуры функций.
Второй способ - это использовать замыкание как отложенную функцию. Так как аргументы вычисляются во время выполнения замыкания:
```go
func main() {
    i, j := 0, 0
    defer func(i int) {
        fmt.Println(i, j)
    }(i)
    i++
    j++
}
```
```
0 1
```
Так как мы передали `i` как параметр отложенной функции - он вычислялся сразу и закрепилось значение 0. А `j` берется из внешнего скопа во время выполнения замыкания, поэтому печатается 1

## Ресиверы значений и указателей
Рассмотрим пример, когда отложенно вызывается метод с ресивером значений:
```go
func main() {
    s := S{"qwe"}
    defer s.print() // qwe
    s.id = "zxc"
}

type S struct {
    id string
}

func (s S) print() {
    fmt.Println(s.id)
}
```
Напечатается qwe, так как мы закрепили за отложенным вызовом метода `id=qwe`.
Но если ресивер будет указательным, то напечатается zxc
```go
func main() {
    s := S{"qwe"}
    defer s.print()
    s.id = "zxc"
}
type S struct {
    id string
}

func (s *S) print() {
    fmt.Println(s.id)
}
```
Вызов метода приводит к копированию ресивера указателя, поэтому изменения внесенные далее видны в отложенном вызове.