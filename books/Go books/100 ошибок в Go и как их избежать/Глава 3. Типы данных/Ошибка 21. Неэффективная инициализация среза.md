[[100 ошибок в Go и как их избежать]]

Это было и в Боднере. Понятное дело, что если там известна будущая длина среза, так делать не надо:
```go
s := make([]int, 0)
```
Во-первых алгоритмически сложно каждый раз копировать значения из старого массива и вставлять в новый, во-вторых это нагружает сборщик мусора, так как старые массивы нужно удалять.

Указывать ненулевую длину или ненулевую емкость? По бенчмаркам ненулевая длина быстрее емкости где-то на 4%. Поэтому здесь нужно исходить из ситуации.
Например тут:
```go
func f(cmp Compare, ts []ts) [][]byte {
	keys := make([][]byte, 0, len(ts) * 2)
	for _, t := range ts {
		keys = append(keys, t.Start.UserKey)
		keys = append(keys, t.End)
	}
}
```
Лучше использовать append, так как вариант с прямым присваиванием нечитаем:
```go
func f(cmp Compare, ts []ts) [][]byte {
	keys := make([][]byte, 0, len(ts) * 2)
	for _, t := range ts {
		keys[i * 2] =  t.Start.UserKey
		keys[i * 2 + 1] = t.End
	}
}
```
