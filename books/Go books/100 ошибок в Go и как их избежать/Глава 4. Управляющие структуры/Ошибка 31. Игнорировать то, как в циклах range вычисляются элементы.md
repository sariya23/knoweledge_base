[[100 ошибок в Go и как их избежать]]

При использовании цикла `for-range exp` `exp` вычисляется единоразово. После вычисления значение копируется в эту временную переменную и потом именно по этой копии происходят итерации 
```go
    s := []int{1, 2, 3}
    for range s {
        s = append(s, 20)
    }
    fmt.Println(s)
```
![[Pasted image 20240901155855.png]]
Вот так выглядит память после 3 итераций. Итерации было всего 2, так как в range копию скопировался слайс с длиной и емкостью 3. 
Если бы мы использовали классический цикл `for`, то  получился бы бесконечный цикл, так как условие цикла проверятся на каждой итерации
```go
    s := []int{1, 2, 3}
    for i, v := range s {
        s[i] = 20
        fmt.Println(v)
    }
   // 1
   // 2
   // 3
```

### Каналы
С каналами такая же история:
```go
    ch1 := make(chan int, 3)
    go func() {
        ch1 <- 1
        ch1 <- 2
        ch1 <- 3
        close(ch1)
    }()
    ch2 := make(chan int, 3)
    go func() {
        ch2 <- 10
        ch2 <- 20
        ch2 <- 30
        close(ch2)
    }()
    ch := ch1
    for v := range ch {
        fmt.Println(v)
        ch = ch2
    }
```
Выводится на экран будут значения из канала `ch1` даже не смотря на то, что на каждой итерации мы присваиваем в `ch` канал `ch2`

### Массивы
И с массивами все то же самое:
```go
    s := [...]int{1, 2, 3}
    for i, v := range s {
        s[2] = 10
        if i == 2 {
            fmt.Println(v)
        }
    }
```
На экран будет выведено значение 3, так как единоразово значения массива скопировались в копию `range`.

Таким образом, в цикле `range` выражение, по которому проводятся итерации, вычисляется только один раз - перед началом цикла, при этом выполняется копирование этого выражения
```go
    s := make([]int, 4)
    s[0], s[1], s[2] = 1, 2, 3
    for _, v := range append(s, 30) {
        fmt.Println(v)
    }
    fmt.Println(s) // [1 2 3 0]
```