[[100 ошибок в Go и как их избежать]]

Дженерики в Go появились в 1.18

Уже какую главу автор не только показывает ошибки использования той или иной шутки, но и напоминает, что это вообще такое - класс
## Концепция
```go
func foo[T any](t T)
```
Эта функция принимает аргумент любого типа. Передача аргумента типа называется инстанцированием. Это выполняется во время компидяции. `T` - это параметр типа

```go
func getKeys[K comparable, V any](m map[K]V) []K {
	// ..
}
```
Эта функция возвращает список ключей карты. Принимает на вход мапу с ключом типа `comparable` - то есть сравнимые типы и с любыми значениями. 
`comparable` - это ограничение типа (constraint). А ограничение типа - это тип интерфейса, который может содержать набор поведения и произвольные типы
```go
type MyConstraint interface {
    ~int
    String() string
}
```
То есть этот констрейнт будет проверять, что тип либо `int`, либо производный от него и что у этого типа есть метод `String() string`

Дженерики можно также использовать со структурами:
```go
type Node[T any] struct {
	Val T
	next *Node[T]
}

func (n *Node[T]) Add(next, *Node[T]) {

}
```

Параметры типа не могут использоваться с аргументами метода, а только с аргументами функции или получателями методов
### Разница между `int` и `~int`
`~int` говорит о том, что тип ограничен либо самим `int`, либо типами, созданными от него. Просто `int` жестко ограничивает `int`
```go
type Cus interface {
    ~int
    String() string
}

type CusInt int

func (i CusInt) String() string {
    return strconv.Itoa(int(i))
}

func f[C Cus](n C) {
    fmt.Println(n)
}

func main() {
    n := CusInt(2)
    f(n)
}
```
Если убрать `~`, то будет ошибка компиляции

## Когда использовать дженерики
- В структурах данных
- Функции, работающие со срезами, картами и каналами любого типа
- Факторизация поведения вместо типов. В пакете `sort` есть интерфейс по сортировки коллекций. Этот интерфейс используется многими функциями: `sort.Ints`, `sort.Float64s`. Используя параметры типа, можно выделить действия по сортировке 

```go
type SliceFn[T any] struct {
    S       []T
    Compare func(T, T) bool
}

func (s SliceFn[T]) Len() int           { return len(s.S) }
func (s SliceFn[T]) Less(i, j int) bool { return s.Compare(s.S[i], s.S[j]) }
func (s SliceFn[T]) Swap(i, j int)      { s.S[i], s.S[j] = s.S[j], s.S[i] }

func main() {
    s := SliceFn[int]{
        S: []int{3, 2, 1},
        Compare: func(a, b int) bool {
            return a < b
        },
    }
    sort.Sort(s)
```
В некоторых случаях нужно явно инстанцировать тип, как в случае с `SliceFn`

## Когда не использовать
- При вызове метода с аргументами типа.
```go
func foo[T io.Writer](w T) {
	// ...
}
```
Тут нет смысла в дженерике.

- Когда это делает код более сложным. Дженириков не было до 1.18 в Go и жили норм, значит не нужно сразу кидаться к ним. Так как дженерики вводят некоторую форму абстракции, а нам нужно помнить, что ненужные абстракции только усложняют работу