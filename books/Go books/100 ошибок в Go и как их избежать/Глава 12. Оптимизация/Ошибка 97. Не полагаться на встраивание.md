[[100 ошибок в Go и как их избежать]]

Термин встраивание (inlining) означает замену вызова функции ее телом. Рассмотрим пример:
```go
func main() {
	a := 3
	b := 2
	c := sum(a, b)
	println(c)
}

func sum(a, b int) int {
	return a + b
}
```
Функция `sum` простая, поэтому компилятор встроил тело функции `sum`. Получился такой код:\
```go
func main() {
	a, b := 3, 2
	c := a + b
	println(c)
}
```
Встраивание работает только для функций с определенным уровнем сложности. Его называются бюджет встраивания. Иначе компилятор сообщит, что функция слишком сложная для встраивания.
У встраивания 2 преимущества:
- Удаляются оверхеды на вызов функций
- После встраивания могут произойти какие-то оптимизации. Например, переменная положится в стек, а не в кучу

Нам нужно знать про встраивание, так как есть концепция встраивания в середине стека (mid-stack inlining). Встраивание в середине стека - это встраивание функций, которые вызывают другие функции. Например:
```go
func main() {
	foo()
}

func foo() {
	x := 1
	bar(x)
}
```
Так как функция `foo` не очень сложная, компилятор может ее встроить:
```go
func main() {
	x := 1
	bar(x)
}
```
Благодаря встраиванию в середину стека можно оптимизировать приложение, используя концепцию встраивания быстрого пути (fast path inlining). Эта концепция состоит в том, чтобы сложную логику выносить в отдельную функцию, а простую - нет, чтобы компилятор встраивал всю функцию.
До появления этой возможности метод `Lock` был реализован так:
```go
func (m *Mutex) Lock() {
	if atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) {
		if race.Enabled {
			race.Acquire(unsafe.Pointer(m))
		}
		return
	}
	var waitStartTime int64
	starving := false
	awoke := false
	iter := 0
	old := m.state
	for {
		// что-то сложное
	}
	if race.Enabled {
		race.Acquire(unsafe.Pointer(m))
	}
}
```
Тут 2 основных пути:
- Если мьютекс не заблокирован (`atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked)` вернуло `true`), то это быстрый путь
- Если заблокирован - медленный
Функция не может быть встроена, так как очень сложная. Чтобы можно было использовать встраивание в середину стека нужно сделать такой рефакторинг, чтобы медленный путь (сложная часть) был в другой функции
```go
func (m *Mutex) Lock() {
	if atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) {
		if race.Enabled {
			race.Acquire(unsafe.Pointer(m))
		}
		return
	}
	m.lockSlow()
}
func lockSlow(m *Mutex) lockSlow() {
	var waitStartTime int64
	starving := false
	awoke := false
	iter := 0
	old := m.state
	for {
		// что-то сложное
	}
	if race.Enabled {
		race.Acquire(unsafe.Pointer(m))
	}
}
```
Теперь метод `Lock` можно встроить, так как быстрая часть простая, а сложная вынесена в отдельную функцию.

Размещение медленного (сложного) пусти внутри отдельной функции предотвращает вызов функции, если выполнение идет по быстрому (простому) пути.