[[100 ошибок в Go и как их избежать]]

## Стек и куча
Когда в Go определяется какая-то функция, то создается фрейм стека - непрерывная область в памяти, доступ к которой может получить только эта функция. Рассмотрим на примере
```go
func main() {
	a := 3
	b := 2
	c := sumVal(a, b)
	println(c)
}
// отключаем встраивание
//go:inline
func sumVal(x, y int) int {
	z := x + y
	return z
}
```
Здесь мы используем функцию `println`, так как используя `fmt.Println` `c` разместилось бы в куче. И мы отключаем встраивание для `sumVal` (об этом в след. главах)
Теперь рассмотрим состояние стека. 
![[Pasted image 20241002123210.png]]
Мы находимся на шаге резервирования места под переменные `a` и `b`. Так как выполняется функция `main`, то для нее был создан фрейм стека. Переменные `a` и `b` были размещены в этом фрейме
![[Pasted image 20241002123312.png]]
Далее мы проваливаемся в функцию `sumValue` и для нее создается новый фрейм стека и в нем размещаются переменные функции. В предыдущем фрейме стека содержатся адреса, которые до сих пор считаются допустимыми. Мы не можем получить к ним доступ напрямую, но если у нас будет указатель, например на `a`, то он тоже будет действительным
Далее мы возвращаемся в `main` на шаг выполнения `println`
![[Pasted image 20241002123506.png]]
Так как мы вышли из `sumValue`, то фрейм стека этой функции был удален, на его место записались переменные из `main`. Переменная `x` стерлась и на ее место записалась `c`, но переменные `y` и `z` остались в памяти, но уже недоступны.
Когда происходит возврат из функции Go не тратит время на чистку памяти. Они остаются, но перезаписываются, когда выделяется память для переменных в род. функции. В некотором смысле *стек очищается сам* - он не требует какого-то доп. механизма, например сборщика мусора.
Проверим, что будет, если мы вернем указатель на переменную, а не значение:
```go
func sumPtr(x, y int) *int {
	z := x + y
	return &z
}
```
![[Pasted image 20241002150700.png]]
Если бы все было именно так, то были бы проблемы. Адрес на `z` был бы недопустим. Фрейм `main` рос и рос и затер бы переменную `z`. Поэтому только стека недостаточно. Поэтому для организации памяти еще есть такой тип как *куча*
*Куча* - это пул памяти, совместно используется всеми горутинами
![[Pasted image 20241002151007.png]]
У каждой горутины есть стек и общая куча. В предыдущем примере переменная `z` не могла разместиться в стеке, поэтому она размещается в куче.
> Если компилятор не может доказать, что переменная не используется после возврата из функции, то место для переменной выделяется а куче

Важно понимать разницу. Стек очищается сам и к нему обращается только одна горутина. Куче же очищается внешней системой - сборщиком мусора. На это требуются значительные ресурсы. Также выделение места в стеке выделяется быстрее, так как указатель ссылается просто на следующий доступный адрес памяти. Выделение места в куче требует больше усилий для поиска свободного места. 
Можем убедиться в этом, написав бенчи:
```go
var globalValue int
var globalPtr *int

func BenchmarkSumValue(b *testing.B) {
    b.ReportAllocs()
    var local int
    for i := 0; i < b.N; i++ {
        local = diffsumm.SumValue(i, i)
    }
    globalValue = local
}

func BenchmarkSumPtr(b *testing.B) {
    b.ReportAllocs()
    var local *int
    for i := 0; i < b.N; i++ {
        local = diffsumm.SumPtr(i, i)
    }
    globalPtr = local
}
```
![[Pasted image 20241002152022.png]]
Видны серьезные различия по скорости. 
Важная оговорочка - нужно избегать преждевременной оптимизации. Если по семантике нам следует использовать указатель, то нужно.

## Эскейп-анализ
Эскейп-анализ - это работа компилятора, в процессе которой он решает, где должна быть выделена переменная: в стеке или в куче. 
Примеры, когда память под переменную может выделятся в куче:
- Глобальная переменная - можно обращаться из нескольких горутин
- Указатель, отправляемый в канал
```go
type Foo struct { s string }
ch := make(chan *Foo, 1)
foo := &Foo{"x"}
ch <- foo
```
Здесь `foo` отправляется в кучу
- Переменная, на которую ссылается какое-то значение, отправляемая в канал:
```go
type Foo struct {s * string}
ch := make(chan Foo, 1)
s := "x"
bar := Foo{&s}
ch <- bar
```
Так как `Foo` ссылается на переменную `s` через ее адрес, то она отправляются в кучу
- Если локальная переменная слишком большая
- Если размер локальной переменной неизвестен. Например, `s := make([]int, 10)` может не размещаться в куче, а вот `s := make([]int, n)` может, так как размер зависит от значения переменной
- Если резервный массив среза переопределяется с помощью `append`

Чтобы проверить можно использовать флаг `-gcflags`

