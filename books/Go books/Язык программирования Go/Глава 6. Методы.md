[[Язык программирования Go]]
Методы можно связывать с любым типом, даже встроенным. 
```go
type MyInt int

func (m MyInt) F() {
	fmt.Println(m)
}

func main() {
	var m MyInt = 10
	m.F() // 10
}
```
Метод связан к конкретным типом, поэтому разные типу могут иметь одни и те же имена
## Методы с указательным ресивером
В релаьных программах соглашение диктует, что если какой-либо метод имеет ресивер указатель, то и все методы этого типа должны иметь ресивер указатель. 
Если у метода ресивер указатель, то не получится вызвать метод через литерал структуры
```go
type S struct{ C int }

func (s S) F()  { fmt.Println("F") }
func (s *S) G() { fmt.Println("G") }

func main() {
	S{1}.F() // F
	S{1}.G() // error
}
```
Так как у компилятора нет никакого способа получить указатель
## Значения-методы и выражения-методы
Метод можно использовать как значение
```go
type S struct{ C int }

func (s *S) F(n int) {
	s.C += n
	fmt.Println(s.C)
}

func main() {
	s := S{1}
	f := s.F
	f(2) // 3
	f(2) // 5
}
```
Со значениями методами тесно связаны выражения-методы. Выражение метод записывается как `T.f` или `(*T).f`, где `T` - тип, а `f` - метод. Вся эта машинерия отдаст обычную функцию с одним из параметров этого типа
```go
func main() {
	f := (*S).F
	s := S{1}
	f(&s, 2) // 3
}
```
