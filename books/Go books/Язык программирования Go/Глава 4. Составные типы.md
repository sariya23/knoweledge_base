## Массивы

> [!Массив]
> Массив представляет собой последовательность фиксированной длины из нуля или более элементов одного типа

Также о массиве можно сказать, что они *гомогенные* (все элементы одного типа)
При создании массива "незаполненные" элементы заполняются нулевыми значениями этого типа
```go
arr := [3]int{1, 2}
fmt.Println(arr[2]) // 0
```
Если в литерале массива использовать `...`, то длина массива *определяется количеством инициализаторов*
```go
arr2 := [...]int{1, 2}
fmt.Println(len(arr2)) // 2
```
==Размер массива является частью его типа==. И размер массива должен быть константым выражением, те выражением, которое можно вычислить во время компиляции
```go
const size = 20
sizeNotConst := 10
arr3 := [size]int{}  // ok
arr4 := [sizeNotConst]int{} // invalid size
```
Также можно создавать разряженные массивы, то есть указывать значение и индекс этого значения. Длина массива будет определятся самым большим индексом
```go
arr := [...]int{0: 20, 100: 1}
fmt.Println(len(arr)) // 101
```
Остальные значения заполняются нулями. 
Если тип элемента массива является сравниваемым, то и сами массивы являются сравниваемыми. 
```go
arr1 := [3]int{1, 2, 3}
arr2 := [3]int{1, 2, 3}
fmt.Println(arr1 == arr2) // true
```
При передачи массива в функцию, передается его копия. Поэтому если массив слишком большой, то это может быть не очень эффективно. 
Функция может принимать указатель на массив, но также если массивы будут разного размера, то функция его не примет
```go
func f(ptr *[32]int) {}
```
Функция `f` примет указатель только на массив размера 32. 
## Срезы
Срез хранит данные в *базовом массиве*. Срез состоит (как структура) из длины, указателя на базовый массив и емкости. 
*Длина* - это количество элементов среза
*Емкость* - это количество элементов между *началом* среза и концом базового массива
Срез вообще в го это структура
Несколько срезов могут совместно использовать один и тот же базовый массив
![[Диаграмма без названия (6) 1.jpg]]
На этой же картинке видно как работает емкость слайса. 
"Срезание" за пределами капасити вызовет панику, а вот если попробуем срезать больше чем текущая длина среза, то срез "расширится"
```go
s1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
s2 := s1[2:5]
fmt.Println(s2[:6]) // [3 4 5 6 7 8]
```
Но если попробуем получить один элемент по индексу за пределами длины, то будет паника. 
Так как в срезе содержится указатель на базовый массив, то при передачи среза в функцию можно изменять элементы базового массива. То есть копирование среза создает лишь *псевдоним* для базового массива.
```go
func f(arr []int) {
	arr[0] = 100
}

arr := []int{1, 2, 3}
f(arr)
fmt.Println(arr)  // {100, 2, 3}
```
### Функция append
Саммари про функцию аппенд - [[Функция append]]
## Отображения
В го мапа это ссылка на структуры хэш-таблицы. 
Создать мапу можно через функцию `make`
```go
ages := make(map[string]int)
```
Это создаст пустую мапу. Также пустую мапу можно создать так
```go
ages := map[string]int{}
```
Удалить пару ключ-значение по ключу можно через функцию `delete`
```go
delete(ages, "name")
```
Важно знать, что элементы мапы - это не переменные. Мы не можем получить их адрес 
```go
&ages["bob"] // error
```
Это потому что при росте мапы может быть выполнена "эвакуация", то есть когда все перехэшируется. Поэтому адрес памяти какого-то ключа можем поменяться. 
Нулевым значением для мапы является `nil`
```go
var ages map[string]int
```
Функции `delete`, `len`, поиск и цикл `for range` безопасно работают с ниловой мапой. Но вот сохранение элемента в ниловую мапу спровоцирует панику. 
### Использование в качестве ключей несравниваемых типов
Для хака можно использовать дополнительную функцию `k`, которая отображает несравниваемый тип к сравниваемому (например, к строке)
```go
m := make(map[string]int)

func k(list []string) string { return fmt.Sprintf("%q", list) }

func Add(list []string) { m[k(list)]++ }
func Count(list []string) int { return m[k(list)] }
```
## Структуры
Именованный структурный тип `S` не может объявить поле того же типа `S`: агрегатное значение не может содержать само себя. Но `S` может объявить поле с типом указателя `*S`.
```go
// Wrong
type S struct {
	value S
}

// Right
type S struct {
	values *S
}
```
Тип структуры без полей называется пустой структурой. Пустая структура не занимает места, поэтому ее часто используют в реализаций множеств через мапы. Но тогда код получается более громоздкий и лучше использовать bool, так как экономия по памяти не сильно большая.
### Структурный литерал
Структурный тип можно создать через структурный литерал
```go
p := Point{1, 2} 
```
Структурный литерал можно записать двумя способами. Первый вариант это перечислить поля без имени *в правильном* порядке (как в примере выше). В таком случае нужно указывать все поля.
Второй способ это перечисление пар поле: значение. Если какое-то поле не указано, то у него будет нулевое значение этого типа
```go
p := Point{X: 2, Y:2}
```
В одном и том же литерале нельзя миксовать эти 2 способа
```go
// Wrong
p := Point{X: 2, 2}
```
Также использую первый вариант (без имен) не получится обойти ограничение неэкспортируемости полей. Код просто не скомпилируется
```go
package s

type T struct {a, b, C int}

package main

import "s"

t := T{1, 2, 3} // compile error
```
### Сравнение структур

> [!NOTE]
> Если все поля структуры сравниваемы, то сравниваема и сама структура

### Встраивание структур
```go
type Point struct {
	X, Y int
}

type Circle struct {
	Point
	Radius int
}

type Wheel struct {
	Circle
	Radius, Spokes int
}
```
Встраивание позволяет выстраивать поведение сложного объекта на основе более мелких. 
При создании структуры со встраиваемыми полями не получится использовать вариант с перечислением имен. Только через точку
```go
var w Wheel
w.X = 20
```
## JSON
Преобразование структуры Go в JSON называется *маршалингом*
```go
data, err := json.Marshal(values)
```
В data будет лежать массив байтов. Но если что можно кастануть к строке, чтобы посмотреть что там вышло. Чтобы формат был более читаемым, можно использовать функцию `MarshalIndent`
```go
data, err := json.MarshalIndent(movies, "", " ")
```
Но байтов, соответсвенно, будет больше. 
Маршализуются только экспортируемые поля. 
Обратная маршалингу операция называется *демаршалинг*. 
```go
var names []struct{Title string}
if err := json.Unmarshal(data, &names); err != nil {
}
```
При демаршалинге регистр символов не учитывается. Поэтому нет необходимости писать к каждому названиея поля json тэг с тем же названием, только с маленькой буквы