[[Язык программирования Go]]
Типы в Go делятся на 4 категории:
- Фундаментальные типы
- Составные типы
- Ссылочные типы
- Типы интерфейсов
## Целые числа
Числовые типы данных включается целые числа нескольких разммеров, числа с плавающей точкой и комплексные числа.
Есть 2 типа, у которых не указан размер - `int` и `uint`. Выбор 32 бита или 64 бита зависит от платформы. Но нельзя делать никаких предположений о их размере, так как даже на одно и тоже железе результаты могут быть разные из-за различных компиляторов
Тип `rune` является алиасом для типа `int32`. По соглашению тип `rune` указывает на то, что данное значение является символом Unicode.
Тип `byte` является алиасом для типа `uint8`. По семантике тип `byte` означает, что число это кусок неформатированных данные, а не просто маленькое число. Выбор в качестве алиаса для руны знакового типа обсусловлен тем, что при переполнении легче отловить ошибку. 
### Арифметика
Приоритет бинарных операторов в Go. Операторы в одной строке имеют один и тот же приоритет
```
1) * / % << >> & &^
2) + - | ^ 
3) == != < <= > >=
4) &&
5) ||
```
Операторы являются *левоассоциативными*, то есть если у операторов одинаковый приоритет, то выполняется выражение слева на право.
Оператор получения остатка `%` применим только к целым числам, иначе будет ошибка компиляции. В Go знак остатка всегда такой же, как и знак делимого, так что `-5%3` и `-5%-3` дадут одинаковый результат `-2`
Поведение оператора `/` зависит от того, является ли *хотя бы* один операнд дробным числом. Если оба числа целые, то будет произведено целочисленное деление. Если хотя бы один дробный, то обычное деление
### Переполнение
Если результат арифтической операции имеет больше битов, чем может быть предоставлено текущим типом, то говорят о переполнении (overflow). При этом старшие биты, которые не помешаются в результат просто отбрасываются. Рассмотрим на примере
```go
	var a, b uint8 = 255, 23
	fmt.Println(a + b) // 22
```
```
 11111111
+
 00010111
---------
100010110
```
Получилось число из 9 бит, старший 9 бит отбрасывается и получается `00010110` или `10110`, что в 10 СС дает результат 22
### Про len
Функция `len` возвращает длину последовательности. Но возвращает они знаковый тип `int`. Казалось бы, что логичнее использовать `uint`. Но это поломало бы все. 
```go
	medals := []string{"A", "B", "C"}
	for i := len(medals) - 1; i >= 0; i-- {
		fmt.Println(medals[i])
	}
```
Если бы `len` возвращала `uint`, то `i` имела бы тоже тип `uint`. Тогда на итерации, где `i==0`, инструкция `i--` привела бы к тому, что там должно быть отрицательное число. Отрицательное число в `uint` лежать не может, поэтому возникла бы паника. 
Поэтому лучше использовать беззнаковые числа только в ситуациях, когда используются побитовые операции.
## Числа с плавающей точкой
Предельные значения с плавающей точно можно найти в пакете `math`. Константа `math.MaxFloat32` наибольшее значение `float32`, и далее аналогично `math.MinFloa32`, `math.MaxFloat64`, `math.MinFloat64`. Но, на примере `float32`,  это нетипизированная контстанта, поэтому
```go
fmt.Println(math.MaxFloat32 * math.MaxFloat32) // 1.1579207543382391e+77
```
Но если привести типы к `float32`, то получим ошибку компиляции о переполении
```go
fmt.Println(float32(math.MaxFloat32) * float32(math.MaxFloat32)) // compile error
fmt.Println(float32(math.MaxFloat32) * float32(2)) // compile error
```
### Бесконечности, NaN
В результате сомнительных математических операций можно получить такие сущности как `NaN` и `+-Inf`
```go
var z float64
fmt.Println(z, 1/z, -1/z, z/z) // 0 +Inf -Inf NaN
```
Если попытаемся поделить на 0 явно (без переменной), то будет ошибка компиляции
```go
fmt.Println(1/0) // compile error
```
Любое сравнение с `NaN` дает `NaN`, поэтому для проверки значения на `NaN` надо использовать специальную функцию `math.IsNaN`
## Строки

> [!Строка]
> Строка - это неизменяемая последовательность байтов

Строки интерпритируются как символы Unicode в кодировке UTF-8.
Функция `len` возвращает количество байтов в строке, а индексирование `s[i]` возвращает итый байт строки. Итый байт строки не обязательно является итым символом строки, так как символы не являющиеся ASCII занимают от 2 двух байт на кодовую точку. 
### Подстрока
Для получения подстроки используется операция `s[i:j]`. Оно возвращает новую строку, но аллокации памяти не происходит. 
Так как строки не изменяемые, то две копии строки могут безопасно разделять одну и ту же память, что делает копирование строки любой длины очень дешевой операцией. 
В го есть структура `StringHeader`
```go
type StringHeader struct {
        Data uintptr
        Len  int
}
```
Вот как располагается в памяти строка и ее подстроки
```go
s := "hello"
s1 := s[:2]
s2 := s[3:]
```
![[Pasted image 20250920115938.png]]
Массив символов общий, а на него ссылаются другие подстроки
### Строковый литерал
Строки можно записывать в двойных кавычках. Внутри них может храниться любая строка и управляющие символы, начинающиеся с `\`
- `\a` - звуковой сигнал
- `\b` - backspace
- `\f` - перевод страницы
- `\n` - новая строка
- `\r` - возврат каретки
- `\t` - табуляция
- `\v` - вертикальная табуляция
- `\'` - одинарная кавычка (экранирование)
- `\"` - двойная кавычка (экранирование)
- `\\` - слэш
Также есть неформатированный строковый литерал (raw string), он записывается с помощью обратных одинарных кавычек (\`\`). Внутри сырых строк не воспринимаются управляющие символы, а также можно использовать несколько строк текста
```go
const a = `Hello
from
raw
string`
```
### Unicode
Каждому символу назначен какой-то номер - код символа Unicode или в терминологии GO - руна 
### UTF8
UTF8 это кодировка переменной длины символов Unicode в виде байтов. Для символов ASCII кодировка требует 1 байт, а для всех остальных от 2 до 4.
Старшие биты первого байта кодировки руны указывают, сколько байтов следуют за первым. Нулевой старший бит указывается, что это ASCII символ, старшие `110` указывают, что руна занимает 2 байта, второй байт при этом начинается с `10`. И так далее
```
0xxxxxxx руны 0-127 (ASCII)

110xxxxx 10xxxxxx 128-2047 

1110xxxx 10xxxxxx 10xxxxxx 2048-65535

11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 65535-0x10ffff
```
Кодировка компактная, совместима с ASCII и обладает самосинхронизацией: всегда можно найти начало символа, посмотрем не более чем 3 байта (см таблицу выше)

Никакой код руны не является подстрокой другого кода или даже последовательности други кодов, поэтому можно искать руны с помощью простого поиска составляющих ее байтов, не беспокоясь о контексте. Это значит, что у каждой руны уникальная последовательность байтов и эта последовательность не может содержаться внутри другой. Также имеет ввиду, что руна - это всегда один кодпоинт. 

Для работы с отдельными символами Unicode необходимо декодирование UTF8. Пакет `unicode/utf8` предоставляет нужные функции

```go
s := "hello 漢"
fmt.Println(len(s)) // 9
fmt.Println(utf8.RuneCountInString(s)) // 7
```
Так как иероглиф не является ASCII символом, то для его кодирования нужно больше чем 1 байт. Для того, чтобы посчитать именно кол-во символов нужно использовать фукнцию `RuneCountInString`. 
Для итерирования нужно также декодировать символы

```go
	for i := 0; i < len(s); {
		r, size := utf8.DecodeRuneInString(s[i:])
		fmt.Printf("%d\t%q\n", i, r)
		i += size
	}
	
0       'h'
1       'e'
2       'l'
3       'l'
4       'o'
5       ' '
6       '漢'
```
Но, цикл по диапазону в Go автоматически декодирует UTF8
```go
	for i, r := range s {
		fmt.Printf("%d\t%q\n", i, r)
	}
	
0       'h'
1       'e'
2       'l'
3       'l'
4       'o'
5       ' '
6       '漢'
```


> [!NOTE]
> Преобразование `[]rune`, примененное к строке в кодировке UTF8, возвращает последовательность символов Unicode, закодированную в этой строке

```go
	s := "汉字"
	fmt.Printf("% x\n", s) // слайс байтов в 16x
	fmt.Println([]rune(s)) // кодпоинты
	
// e6 b1 89 e5 ad 97
// [27721 23383]
```
Обратное преобразование из `[]rune` в строку
```go
string([]rune(s))
```
### Строки и байтовые срезы
Для работы со строками важны эти 4 стандартных пакета:
- `bytes`. Аналогичные функции, что и в `strings`, только для работы с `[]byte`
- `strings`. Функции для поиска, замены, сравнения, обрезки строк
- `strconv`. Фукнции для преобразование чисел и булевых значений в строковое представление и обратно

Строка содержит массив байтов, который является неизменным. Строки можно преобразовывать в байтовые срезы и обратно
```go
s := "abc"
b := []byte(s)
s2 := string(b)
```
Преобразование `[]byte(s)` выделяет память для нового массива байтов, хранящего копию байтов строки `s` и дает срез, ссылающийся на весь этот массив. Иногда компилятор может там что-то оптимизровать и копирования не произойдет. Преобразование к строке `string(s)` также создает копию. 
## Константы

> [!Константа]
> Константы это выражения, значения которых известны компилятору и вычисление которых гарантировано происходит во время компиляции, а не во время выполнения

Объявление `const` объявляется *именованное* значение. Из-за того, что константы вычисляются во время компиляции, то некоторые ошибки видны сразу, например, деление на ноль
```go
	const a = 0
	fmt.Println(1 / a) // zero division via compile
```
Результаты всех арифметических и логический операций, а также операций сравнения с операндами константами также являются константами, как и результаты некоторых функций: `len` (только к массиву), `cap` (только к массиву), `real`, `imag`, `complex`, `unsafe.Sizeof`
### Генератор констант iota
Это что-то вроде автоинкремента по определенному правилу. Например
```go
type Weekday int

const (
	Sunday Weekday = iota
	Monday
	Tuesday
	Wednesday
	//...
)
```
Начнется все с нуля и так далее. 
### Нетипизированные константы
Многие константы не привязаны к определенному типу. Компилятор представляет эти не привязанные к типу константы с гораздо большей числовой точностью. Имеется 6 вариантов таких несвязанных констант:
- нетипизированные булевые значения
- нетипизированные целые числа
- нетипизированные руны
- нетипизированные числа с плавающей точкой
- нетипизированные комплексные числа
- нетипизированные строки
Нетепизированность констант позволяет применять меньше кастов типов в коде. Например, `math.Pi`
```go
	var x float32 = math.Pi
	var y float64 = math.Pi
	var z complex128 = math.Pi
```
