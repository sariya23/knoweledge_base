[[Язык программирования Go]]

Уже не в первый раз вижу такое в книгах по Go:
> в особенности для локальных переменных с небольшими областями видимости; гораздо больше шансов встретить переменную `i`, чем переменную `theLoopIndex`. Словом, чем больше область видимости имени, тем длиннее и значимее оно должно быть

## Переменные
Переменные уровня пакета инициализируются до начала выполнения функции `main`, а локальные переменные инициализируются тогда, когда в процессе выполнения функции встречаются их объявления.

### Краткое объявление переменной
Не забывайте, что что объявление - это `:=`, а `=` - это присваивание. 
### Указатели
Значение указателя представляет собой адрес переменной.
Два указателя равны тогда и только тогда, когда они указывают на одну и ту же переменную или когда они оба равны `nil`
Функция совершенно безопасно может вернуть адрес локальной переменной.
### Функция `new`
Выражение `new(T)` создает неименованную переменную типа `T`, инициализирует ее нулевым значения типа `T` и возвращает ее адрес, который представляет собой значение типа `*T`
```go
p := new(int) // *int
fmt.Println(*p) // 0
```
`new` является синтаксическим удобством. Эти две функции делают одно и то же
```go
func f() *int {
	return new(int)
}

func g() *int {
	var dummy int
	return &dummy
}
```
### Время жизни переменных
Время жизни переменной уровня пакета равно времени работы всей программы.

## Объявление типов
Преобразование одного типа в другой разрешено, если они оба имеют один и тот же базовый тип или если они оба являются неименованными указателями на переменные одного и того же базового типа. 
```go
type A int
type B int
func main() {
    var a A
    var b B
    a = 20
    b = 30
    fmt.Println(B(a))
    fmt.Println(A(b))
}
```
## Импорт
```go
import "fmt"
```
Спецификация языка нее определяет, откуда берутся строки или что они означают; их интерпретация - дело соответствующего инструмента  
