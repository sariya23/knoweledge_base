[[Книги]]

Специальные (дандер) методы, это методы, которые должен вызывать интерпретатор, а не пользователь. 
## Сырое форматирование
Если мы хотим реализовать какой-то метод `__str__` или `__repr__`, то лучше реализовывать последний. Также есть удобный символ для форматирования в f-строках: `!r`, который применит к объекту метод `__repr__`. Это удобно, чтобы при отладке различать строки и числа, например
```python
class C:
    def __repr__(self):
        return f"C(a={1!r}, b={'2'!r})"

a = C()
print(f"{a}")  # C(a=1, b='2')
```
## Про `len`
Если при `len(x)`, `x` является встроенным типом, то метод `__len__` не вызывается, а берется из значения поля структуры - https://github.com/python/cpython/blob/main/Include/cpython/listobject.h#L5. 
Также `len` является функцией, а не методом, так как под капотом, как было написано выше, мы лезем в сишную структуру. Но, благодаря методу `__len__` мы можем заставить работать эту функцию и с пользовательскими объектами. Также это убирает вопросы по типу: а вот у этого объекта как получить кол-во элементов? Всегда `len(x)`. То есть можно было бы сделать и так, чтобы `len` у встроенных типов ходил в структуру, а пользовательские объекты вызывали бы этот метод напрямую, но тогда была бы нарушена согласованность.  
## Модель данных
Благодаря специальным методам, юзеры могут создавать свои объекты, которые будут работать с теми же функциями, что и встроенные. Например, определив метод `__contains__`можно проверять есть ли значение или нет через оператор `in`.  