[[100 ошибок в Go и как их избежать]]

## Гонка данных (data race) и состояние гонки (race condition)
Гонка данных (data race) происходит, когда две или более горутины одновременно обращаются к одной и той же ячейки памяти и по крайней мере одна из них выполняет запись в эту ячейку
Пример гонки данных:
```go
i := 0
go func() {
	i++
}()
go func() {
	i++
}()
```
Результат выполнения кода детерминирован. Иногда в i может лежать 1, а иногда 2. При инкременте происходит 3 действия:
- Чтение i
- Увеличение i на 1
- перезапись нового значения в i

Если первая горутина выполняется и ее выполнения завершается раньше, чем у второй, то происходит это:
![[Pasted image 20240908141527.png]]
Первая горутина читает, увеличивает и записывает значение 1 в i, а потом вторая горутина делает то же самое. Но нет никаких гарантий, что поток выполнения всегда будет такой. Он может быть и такой:
![[Pasted image 20240908141627.png]]
Мы можем столкнуться с чередующемся выполнением, когда обе горутины выполняются одновременно и конкурируют за доступ к i. 
### Как предотвратить гонку данных
#### Атомарные операции
Мы можем сделать операцию атомарной, то есть такой, которая выполняется целиком за один шаг. Тогда потом выполнения может быть такой:
![[Pasted image 20240908141830.png]]
Атомарные операции находятся в пакете `sync/atomic`
```go
var i int64
go func() {
	atomic.AddInt64(&i, 1)
}()
go func() {
	atomic.AddInt64(&i, 1)
}()
```
Когда нам нужно делать какие-то другие операции атомарно и с другими типами этот пакет не подойдет, так как там есть не все типы
#### Мьютексы
С помощью мьютексов можно гарантировать, что к критической секции будет одновременно обращаться только одна горутина
```go
i := 0
mutex := sync.Mutex{}
go func() {
	mutex.Lock()
	i++
	mutex.Unlock()
}()
go func() {
	mutex.Lock()
	i++
	mutex.Unlock()
}()
```
#### Связь через каналы
Еще один вариант - это запретить совместное использование одного и того же места в памяти и отдать предпочтение взаимодействию между горутинами.
Например, создать канал, который каждая горутина использует для получения значения инкремента
```go
i := 0
ch := make(chan int)
go func() {
	ch <- 1 
}()
go func() {
	ch <- 1 
}()
i += <-ch
i += <-ch
```

### Состояние гонки (race condition)
Рассмотрим пример состояние гонки:
```go
i := 0
mutex := sync.Mutex{}
go func() {
	mutex.Lock()
	defer mutex.Unlock()
	i = 1
}()
go func() {
	mutex.Lock()
	defer mutex.Unlock()
	i = 2
}()
```
Гонки данных тут нет, так как обе горутины обращаются к одной и той же переменной, которая помещена в крит. секцию. Но результат не будет детерминированным. 
Но в зависимости от порядка выполнения значение в i будет разное. Состояние гонки возникает, когда поведение зависит от последовательности или времени выполнения событий, которые невозможно контролировать. 
## Модель памяти Go
- Создание горутины происходит до начала выполнения этой горутины. Следовательно, чтение переменной, а затем запуск новой горутины, которая производит запись в эту переменную, не провидит к гонке данных
```go
i := 0
go func() {
	i++
}()
```
- Выход их горутины не обязательно произойдет до наступления какого-либо события. В след. примере есть гонка данных
```go
i := 0
go func() {
	i++
}()
fmt.Println(i)
```
- Отправка по каналу происходит до завершения соответствующего приема из этого канала.
- Закрытие канала происходит до получения замыкания
- Примем из небуферезированного канала происходит до завершения отправки по этому каналу