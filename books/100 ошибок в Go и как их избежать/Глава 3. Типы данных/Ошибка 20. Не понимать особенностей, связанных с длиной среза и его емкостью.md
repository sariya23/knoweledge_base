[[100 ошибок в Go и как их избежать]]

Глава вообще кайф - схемы огонь!

В Go за срезом стоит. Срез это структура из 3 полей - ссылка на массив, длина и емкость.
Создадим срез с длиной 3 и емкостью 6
```go
s := make([]int, 3, 6)
```
Вот так это выглядит в памяти:
![[Диаграмма без названия (5) 1.jpg]]
Серые элементы - это выделенная, но не занятая память.
Добавляя элементы мы будем увеличивать длину. Но как только длина станет равна емкость, то компилятор создаст другой массив, удвоит его емкость (пока она не станет 1024 элемента, далее увеличение на 25%) и скопирует все элементы из старого массива в новый:
![[Диаграмма без названия (6).jpg]]
Старый массив удалится сборщиком мусора, если на него больше нет ссылок.

Посмотрим, как работает срезание срезов
```go
s1 := make([]int, 3, 6)
s2 := s1[1: 3]
```
![[Диаграмма без названия (8).jpg]]
Оба среза ссылаются на один и тот же массив в памяти. То есть меняя элементы в одном - изменения будут видны в другом
```go
s2[0] = 20
```
![[Диаграмма без названия (9).jpg]]
Теперь попробуем добавить еще один элемент в `s2`
```go
s2 = append(s2, 100)
```
![[Диаграмма без названия (10).jpg]]
Общий массив изменяется, но длина меняется только у второго среза. Первый срез не видит дальше свой длины. 
А что произойдет, если добавлять элементы во второй срез до тех пор, пока длина не превысит емкость
```go
    s2 = append(s2, 200)
    s2 = append(s2, 300)
    s2 = append(s2, 400)
```
Как было написано выше, при достижении длины ёмкости создается новый массив, в который все копируется:
![[Диаграмма без названия (11).jpg]]