[[100 ошибок в Go и как их избежать]]

Рассмотрит такой код:
```go
s1 := []int{1, 2, 3}
s2 := s1[1:2]
s3 := append(s2, 10)
```

Вот как выглядят срезы s1 и s2 до выполнения третей строки:
![[Диаграмма без названия (12).jpg]]
У s2 хватит места еще на один элемент. При выполнении третей строчки ситуация в памяти будет такая:
![[Диаграмма без названия (14).jpg]]
То есть путаница полнейшая. Первый срез увидит 10, так как длина равна 3. Второй срез не увидит 10, так как его длина 1, а меняется элемент за пределами его длины. Третий срез ну тут понятно
```
s1 = [1 2 10]
s2 = [2]
s3 = [2 10]
```

Этот принцип действует и при передаче слайса в функцию:
```go
func main() {
    s := []int{1, 2, 3}
    f(s[:2])
    fmt.Println(s) // [1 2 20]
}

func f(arr []int) {
    _ = append(arr, 20)
}
```
То есть если в функции происходит обновление первый двух элементов, то эти изменения будут видны в оригинальном срезе. Но если мы увеличим емкость, то все будет ок. При срезе срез получает максимальную емкость среза.
Если мы хотим защититься от этого, то есть 2 варианта:
- Передавать копию среза, полученную с помощью `copy`
- Использовать полное выражение среза - `[low:high:maxCap]` в этом случае емкость полученного среза будет равно `maxCap - low`. 
```go
func main() {
    s := []int{1, 2, 3}
    f(s[:2:2])
    fmt.Println(s) // [1 2 3]
}

func f(arr []int) {
    _ = append(arr, 20)
}
```