[[100 ошибок в Go и как их избежать]]

## Концепция
В Go есть 10 типов целых чисел, каждое со своим максимальным и минимальным значением. А что произойдет, если во время выполнения в максимальное число добавить что-то?
```go
var counter int32 = math.MaxInt32
counter++
fmt.Println(counter)
```
Код компилируется и выполняется, но на выходе мы получим что-то вроде:
```
-2147483648
```
Такая штука происходит, когда арифметическое действие приводит к переполнению. Есть 32 бита и когда ну некуда пихать уже биты сбрасываются и первый бит знака становится равен 1 (-), а остальные 0.
Переполнение может быть замечено на этапе компиляции:
```go
var couinter int32 = math.MaxInt32 + 1
```

## Обнаружение целочисленного переполнения
### При инкременте
При инкрементировании переполнение можно обнаружить через условие, в котором счетчик сравнивается с максимально допустимым значением типа:
```go
if counter == math.MaxInt32 {
	panic("overflow")
} else {
	counter++
}
```
Для других типов в пакете math тоже определены константы. Для uint логика такая же.

### При сложении
```go
if a > math.MaxInt - b {
	panic("overflow")
} else {
	a + b
}
```

### При умножении
```go
func Mult(a, b int) int {
	if a == 0 || b == 0 {
		return 0
	}
	result := a * b
	if a == 1 || b == 1 {
		return result
	}

	if a == math.MinInt || b == math.MinInt {
		panic("overflow")
	}
	if result / b != a {
		panic("overflow")
	}
	return result
}
```
Тут уже шагов по больше. 
