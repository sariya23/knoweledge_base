[[100 ошибок в Go и как их избежать]]

Скелет любого бенчмарка:
```go
func BenchmarkFoo(b *testing.B) {
	for i := 0; i < b.N; i++ {
		foo()
	}
}
```
На выходе мы получаем сколько раз была выполнена `foo` и среднее время выполнения в наносекундах. По умолчанию бенчмарк идет 1 секунду, но это можно изменить, передав `-benchtime=<n>s`

## Не сбрасывать или не ставить на паузу таймер 
Иногда перед самим бенчмарком нужно выполнить какую-то дорогую операцию. Что она не влияла на результат всего бенчмарка нужно сбрасывать таймер:
```go
func BenchFoo(b *testing.B) {
	expensiveSetup()
	b.ResetTimer() // сброс таймера
	for i := 0; i < b.N; i++ {
		foo()
	}
}
```
Иногда нужно выполнять сетап на каждой итерации цикла. Для этого нужно стопать и запускать таймер:
```go
func BenchFoo(b *testing.B) {
	for i := 0; i < b.N; i++ {
		b.StopTimer()
		expensiveSetup()
		b.StartTimer()
		foo()
	}
}
```
## Делать неверные предположения о микробенчмарках
Микробенчмарк измеряет крошечную вычислительную единицу. Так как они выполняются ОЧЕНЬ быстро, то нам результат может повлиять все, что угодно. Режим управления питанием и другие факторы, которые выходят за рамки Go.
Первое решение - это увеличить время выполнения бенча с помощью `-benchtime`. Так как у нас будет больше наблюдений, то и результат будет ближе к ожидаемому.
Второе решение - использование внешних инструментов. Например, `benchstat`. Запустим бенчи 10 раз и запишем результат в файл:
```shell
go test -bench=. -count=10 | tee stats.txt
```
А затем эту утилиту:
```shell
benchstat stats.txt
```
Там покажется сводка о выполнении 2ух типов бенчев

## Небрежное отношение к оптимизации компилятора
Оптимизация компилятора тоже может приводить к неверным результатам бенчмарка. Например, есть такая функция
```go
func popcnt(x uint64) uint64 {
	x -= (x >> 1) & m1
	x = (x & m2) + ((x >> 2) & m2)
	x = (x + (x >> 4)) & m4
	return (x * h01) >> 56
}
```
И бенчмарк для нее
```go
func BenchmarkPopcnt1(b *testing.B) {
	for i := 0; i < b.N; i++ {
		popcnt(uint(64))
	}
}
```
После выполнения мы получим, что функция выполнилась 1_000_000 раз и среднее время 0.25 нано сек. Это ОЧЕНЬ мало, примерно, один тактовый цикл. По факту эта функция не разу не выполнилась. Так как она слишком проста для встраивания (inlining). Ее вызов не приводит ни к каким побочным эффектам.
Чтобы такого игнорирования не происходило можно сделать вот что:
- Во время каждой итерации в цикле присваивать результат какой-то локальной переменной
- При последнем выполнении цикла результат присвоить какой-то глобальной переменной

```go
var global uint64

func BenchmarkPopcnt2(b *testing.B) {
	var v uint64
	for i := 0; i < b.N; i++ {
		v = popcnt(uint64(i))
	}
	global = v
}
```
Теперь оптимизация не будет влиять.
## Эффект наблюдателя
Рассмотрим этот эффект на примере функции, которая получает матрицу из 512 столбцов и нужно вычислить сумму первых 8 столбцов. А потом в целях оптимизации определить, оказывает ли изменение кол-ва столбцов на время работы
```go
func calcSum512(m [][512]int) int {
	var sun int
	for i := 0; i < len(m); i++ {
		for j := 0; j < 8; j++ {
			sum += s[i][j]
		}
	}
	return sum
}

func calcSum513(m [][512]int) int {
	// the same
}
```
Напишем бенчамарк
```go
const rows = 1000

var res int

func BenchmarkCalcSum512(b *testing.B) {
	var sum int
	s := createMatrix512(rows)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sum = calcSum512(s)
	}
	res = sum
}

func BenchmarkCalcSum513(b *testing.B) {
	var sum int
	s := createMatrix513(rows)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sum = calcSum512(s)
	}
	res = sum
}
```
Ожидается, что результаты будут примерно такие же. Но нет. Может быть такое, что с 513 столбцами будет быстрее. Почему так? Дело в том, что мы используем одну и ту же матрицу в обоих случаях, это происходит из-за кэша (в след. ошибках)
Чтобы такого не происходило, на каждой итерации нужно создавать новую матрицу.