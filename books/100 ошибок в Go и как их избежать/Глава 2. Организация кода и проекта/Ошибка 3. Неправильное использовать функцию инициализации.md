[[100 ошибок в Go и как их избежать]]

## О функции `init`
Функция `init` не принимает параметров и не возвращает значений. 
Порядок инициализации в пакете:
- Сначала константы и переменные
- Потом функция инициализации

Например:
```go
var a = func() int {
    fmt.Println("In var func")
    return 0
}()

func init() {
    fmt.Println("Init func")
}

func main() {
    fmt.Println("main func")
}
```
```
In var func
Init func
main func
```

Если у нас есть пакет `main`, который зависит от пакета `pckg1`, в котором определена функция `init`, то сначала выполнится функция `init` в пакете `pckgh1`, а потом уже в пакете `main`. 

Функций `init` может быть несколько - в таком случае выполнится та, которая в файле с меньшим названием. То есть если функции `init` есть в файлах `a.go` и `b.go` в каком-то пакете, то сначала эта функция выполнится в файле `a.go`

Функцию `init` нельзя вызвать напрямую

## Когда использовать функцию `init`
Рассмотрим пример использования `init` для создания соединения с БД:
```go
var db *sql.DB

func init() {
	dataSourceName := os.Getenv("SMTH")
	d, err := sql.Open("mysql", dataSourceName)
	if err != nil {
		log.Panic(err)
	}
	err = d.Ping()
	if err != nil {
		log.Panic(err)
	} 
	db = d
}
```
Недостатки такого подхода:
- **Ограниченная обработка ошибок**. Так как функция `init` не может возвращать значений при ошибке нам остается только вызывать панику. Это связывает нам руки, так как возможно мы бы хотели обработать эту ошибку в не пакета
- **Неудобство тестирования**. Если мы добавим тесты в этот пакет, то функция инициализации будет вызываться каждый раз, что тоже может нам не нужно
- **Использование глобальной переменной**

Из-за таких недостатков лучше использовать простую функцию

Нужно ли избегать ее совсем? Нет. Иногда полезно. Например при определении статической конфигурации