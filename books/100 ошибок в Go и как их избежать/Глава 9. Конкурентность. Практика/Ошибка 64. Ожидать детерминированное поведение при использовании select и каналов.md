[[100 ошибок в Go и как их избежать]]

Допустим, мы хотим реализовать горутину, которая должна получать данные из двух каналов: `messageCh` для новых сообщений, `disconnectCh` - для получения уведомлений об отключении
```go
for {
	select {
		case v := <- messageCh:
			fmt.Println(v)
		case <- disconnectCh:
			fmt.Println("disconnect")
			return
	}
}
```
Проблема в том, что если и в канале с новыми сообщениями будут данные, и в канале об отключении, то Go выполнит рандомный case, а не тот, который стоит первым. Так сделано специально, чтобы предотвратить возможное голодание (starvation). Мы можем попасть в ситуацию, когда получим данные только от самого быстрого отправителя.

Как решать эту проблему? Если у нас одна горутина, то можно использовать небуферезированный канал, так как отправитель заблокируется до тех пор, пока горутина получатель не будет готова. Также можно использовать один канал вместо двух.
Если же у нас несколько горутин, то нужно при получении уведомления об отключении прочитать все сообщения из канала с сообщениями:
```go
for {
	select {
		case v := <- messageCh:
			fmt.Println(v)
		case <- disconnectCh:
			for {
				select {
					case v := <- messageCh:
						fmt.Println(v)
					default:
						fmt.Println("disconnect")
						return
				}
			}
	}
}
```