[[100 ошибок в Go и как их избежать]]

Ну тут вообще жесть какая низкоуровневая оптимизация. 
Есть такой код:
```go
const n = 1_000_000

func add(s [2]int64) [2]int64 {
	for i := 0; i < n; i++ {
		s[0]++
		if s[0] % 2 == 0 {
			s[1]++
		}
	}
	return s
}
```
Процессор можно выполнять инструкции параллельно. Вот как упрощенно выглядят текущие инструкции
![[Pasted image 20240930182739.png]]
Параллелизм на уровне инструкций - ILP. ![[Pasted image 20240930182829.png]]
Преимущества и недостатки те же, что и у конкурентного кода. При текущей реализации будет много конфликтов данных
![[Pasted image 20240930182906.png]]
Вот как будет оптимизировано
```go
const n = 1_000_000

func add(s [2]int64) [2]int64 {
	for i := 0; i < n; i++ {
		v := s[0]
		v++
		s[0] = v
		if v % 2 == 0 {
			s[1]++
		}
	}
	return s
}
```
У автора похоже ошибка в коде
![[Pasted image 20240930183424.png]]
Проверяется не увеличенное значение `v`. Но это неточно.
В общем суть в чем, так как мы разнесли данные по разным переменным, мы уменьшили число конфликтов
![[Pasted image 20240930183502.png]]
Но как будто эта оптимизация нужна только для программирования хз чего