[[100 ошибок в Go и как их избежать]]

Сокращение выделений памяти (allocations) - метод оптимизации

## Изменения API
Возьмем в качестве примера интерфейс `io.Reader`
```go
type Reader interface {
	Read(p []byte) (n int, err error)
}
```
А что бы было, если бы метод `Read` принимал число байт для чтения и возвращал срез этих прочитанных байт
```go
type Reader interface {
	Read(n int) (p []byte, err error)
}
```
С точки зрения семантики все в порядке, но тогда бы возвращаемый срез размещался в куче. Небольшое изменение API можно оптимизировать приложение

## Приемы оптимизации компилятора
Одна из целей компилятора Go - оптимизировать код. Рассмотрим пример с картами.
Так как срез не может быть ключом карты, но мы хотим сделать ключем значение, которое прилетает нам в виде среза байт, то мы преобразуем их в строку:
```go
type cache struct {
	m map[string]int
}

func (c *cache) get(bytes []byte) (v int, contains bool) {
	key := string(bytes)
	v, contains = c.m[key]
	return
}
```
Но компилятор Go проделывает некоторую оптимизацию в случае преобразования на месте:
```go
func (c *cache) get(bytes []byte) (v int, contains bool) {
	v, contains = c.m[string(bytes)]
	return
}
```
Код почти такой же, но компилятор будет избегать преобразования байтов в строку

## sync.Pool
`sync.Pool` - это не кэш. Это просто пул объектов, чтобы можно было их переиспользовать
Предположим у нас есть функция, которая получает ответ в виде байтов, а потом их записывает в `io.Writer`
```go
func write(w io.Writer) {
	b := getResponse()
	_, _ = w.Write(b)
}
```
`getResponse` при каждом вызове возвращает новый срез `[]byte`. Что, если мы хотим переиспользовать этот срез? Пусть все ответы имеют максимальную длину 1024 байта. Тут можно использовать `sync.Pool`.
Для создания `sync.Pool` нужна фабричная функция `func() any`. У `sync.Pool` два метода:
- `Get() any` - для получения объекта из пула
- `Put(any)` - кладет объект в пул
При выполнении `Get` либо создается новый объект, если пул пуст, либо объект используется повторно. Объекты из пула удаляются сборщиком мусора.
```go
var pool = sync.Pool{
	New: func() any {
		return make([]byte, 1024)
	}
}

func writer(w io.Writer) {
	buffer := pool.Get().([]byte)
	buffer = buffer[:0]
	defer pool.Put(buffer)
	getResponse(buffer)
	_, _ = w.Write(buffer)
}
```