[[100 ошибок в Go и как их избежать]]

Еще видос про выравнивание - https://www.youtube.com/watch?v=KQd7bAV5npw&ab_channel=%D0%90%D0%BD%D0%B4%D1%80%D0%B5%D0%B9%D0%A8%D0%B5%D1%81%D1%82%D0%B0%D0%BA%D0%BE%D0%B2

Посмотрим, что бы было, если бы не было выравнивания данных. Предположим, что память выделяется под 2 переменные
```go
var i int32
var j int64
```
Без выравнивания данных в 64-ой ОС их можно было бы разместить так:
![[Pasted image 20241001210214.png]]
То есть переменная j может располагаться в ячейках, которые относятся к разным машинным словам (64 бита в 64-ОС)
***Чтобы этого не происходило, адрес переменной в памяти должен быть кратен ее размеру. Это и есть концепция выравнивая данных.*** 

Все числовые типы в Go гарантировано выровнены. То есть переменная типа `byte` будет лежать в ячейке памяти, кратной 8.
![[Pasted image 20241001210423.png]]
Во втором случае `j` не может быть рядом с `i`. Серый квадрат значит заполнение (padding)
Рассмотрим структуру с тремя полями:
```go
type Foo struct {
	b1 byte
	i int64
	b2 byte
}
```
В 64-ОС эта структура размещается в памяти так:
![[Pasted image 20241001210624.png]]
Адрес `b1` должен быть кратен 1, первый доступный адрес `0x00`. У типа `int64` адрес должен быть кратен `8` - это адрес `0x08`. Ну а `b2` тоже кратен 1. Размер структуру должен быть кратен размеру машинного слова (8 байт в 64-ОС), поэтому ее адрес занимает не 17 байт, а в общем 24 байта. Во время компиляции Go добавит padding, для выравнивания данных
```go
type Foo struct {
	b1 byte
	_ [7]byte
	i int64
	b2 byte
	_ [7]byte
}
```

Как уменьшить этот объём? 
> Эмпирическое правило - сортировать поля структуры по размеру типов в порядке *убывания*

```go
type Foo struct {
	i int64
	b1 byte
	b2 byte
}
```
![[Pasted image 20241001211121.png]]
Размер структуры должен быть все равно кратен размеру слова, но теперь это 16 байт, а не 24.

Сортировка полей структуры позволяет уменьшить размер структуры и уменьшить частоту обращения к GC. 