[[Go]]
То, как реализована функция `append`
```go
func Append(slice []int, elements ...int) []int {
    n := len(slice)
    total := len(slice) + len(elements)
    if total > cap(slice) {
        // Reallocate. Grow to 1.5 times the new size, so we can still grow.
        newSize := total*3/2 + 1
        newSlice := make([]int, total, newSize)
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[:total]
    copy(slice[n:], elements)
    return slice
}
```
Вводные для понимания. 
Слайс - это структура из 3 полей:
```go
type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
```
Ссылка - https://github.com/golang/go/blob/32dfd69282ac86b0ce49909d36e2a4e5797ad25c/src/runtime/slice.go#L4
## Перевыделения памяти не происходит
Рассмотрит ситуацию, когда код выглядит так
```go
func Append(slice []int, elements ...int) []int {
    n := len(slice)
    total := len(slice) + len(elements)
    slice = slice[:total]
    copy(slice[n:], elements)
    return slice
}
```
Какие тут подводные камни? Вообще достаточно :)
Общий алгоритм работы: 
1. Получаем длину слайса, которая будет после добавления элементов
2. Расширяем 
### Ошибка №1. Не понимать, что слайс не видит за пределы своей длины
ОЧЕНЬ важно помнить, что слайс смотрит только до того момента, пока его "указатель" не перешел показатель длины. Например:
```go
	a1 := make([]int, 0, 10) // len=0, cap=10
	a1 = append(a1, []int{1, 2, 3}...)
	a2 := a1
	a2 = append(a2, 4)
	fmt.Print(a1, a2)
```
Вывод будет соответсвенно `[1 2 3] [1 2 3 4]`. То есть не смотря на то, что массив у обоих этих срезов общий, первый слайс не меняется, так как длина увеличивается только у второго. Вот как это выглядит в памяти
![[Диаграмма без названия (7) 1.jpg]]
### Ошибка №2. Не понимать, что входящий слайс никак не меняется
Это чисто моя непонятка. В фрагменте кода:
```go
a = []int{1, 2, 3}
a2 = append(a1, 2)
```
`a1` НИКАК НЕ МЕНЯЕТСЯ. ВООБЩЕ. Что меня смущало:
```go
    slice = slice[:total]
    copy(slice[n:], elements)
```
Вот это вот. Когда мы вызываем `append(x, n)`, то в `append` передается *ссылка* на структуру. То есть если длина слайса изменится внутри функции, то поменяется КОПИЯ той, внешней структуры. Поэтому с входязим массивом НИЧЕГО не происходит. Он как имел длину перед вызовом `append`, так и имеет. Вот как это выглядит
![[Диаграмма без названия (8) 1.jpg]]
### Ошибка №3. Не понимать следствий из того, что базовый массив - общий
Рассмотрим вот такой пример
```go
	1 a1 := make([]int, 0, 10)
	2 a1 = append(a1, []int{1, 2, 3, 4}...)
	3 a2 := append(a1, 5)
	4 fmt.Println(a2)
	5 a3 := append(a1, 6)
	6 fmt.Println(a3)
	7 fmt.Println(a1, a2, a3)
```
И вывод
```
[1 2 3 4 5]
[1 2 3 4 6]
[1 2 3 4] [1 2 3 4 6] [1 2 3 4 6]
```
Основная загвоздка тут в 6, которая оказалась в итоге и в `a2` и в `a3`. Все дело в общем базовом массиве. Рассмотрим, что происходит в момент 4
![[Диаграмма без названия (9) 1.jpg]]
Тут ничего сложного. 5 добавилась в общий базовый массив, но `a1` этого не видит. А `a2` все отлично видит. Теперь рассмотрим, что происходит в момент 5. Во-первых, на что стоит обратить внимание, в функцию `append` мы передаем тот же слайс `a1`, который имеет длину 4. Длина `total` равна 5 (длина + 1 новый элемент). Часть `slice = slice[:total]` вернет слайс с `[1 2 3 4 5]`. Но потом `copy(slice[n:], elements)` вот эта строчка просто перезатрет 5 и вставит туда 6. 
![[Диаграмма без названия (10) 1.jpg]]
Длина `a2` и `a3` одинаковая, то есть видят они тоже одинаково. А видят они 6 :) Вот такая интересная фишка. 
## Перевыделение памяти происходит
Тут на самом деле ничего интересного нет. Просто создается новый базовый массив и все
## Каверзные задачи
```go
package main

import "fmt"

// 1 2 3
// len=3
// cap=3

func main() {
	nums := []int{1, 2, 3}
	addNum(nums[:2])  // len=2 cap=3 [1 2]
	fmt.Println(nums) // 1 2 4
	addNums(nums[:2]) // len=2 cap3 [1 2]
	fmt.Println(nums) // 1 2 4
}

func addNum(nums []int) {
	// len=2 cap=3
	nums = append(nums, 4)
}

func addNums(nums []int) {
	nums = append(nums, 5, 6) // len=4 cap>6
}
```