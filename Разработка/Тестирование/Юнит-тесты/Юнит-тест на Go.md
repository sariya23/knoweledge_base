[[Юнит-тесты]]
Чтобы написать юнит-тест на Go нужно соблюсти такой контракт:
- Название файла с юнит тестом должно кончатся на `_tes.go`. Такой файл не включается в бинарную сборку проекта
- Название функции теста должно начинаться в `Test` и принимать `*testing.T`
Запуск тестов:
```shell
go test
```
Или чтобы запустить все тесты:
```shell
go test ./...
```
На запуск всех тестов есть важная конвенция. При запуске `go test ./...`  (всех тестов) запускаться должны ВСЕ юнит тесты. Но, если какой-то тест требует БД или кафки, то есть по сути интеграционный, то он *не должен* запускаться таким образом 
Флаг `-v` добавляет более подробный вывод 
### Табличные тесты
Табличные тесты позволяют написав один тест проверить много комбинаторики
```go
func TestPow(t *testing.T) {
	cases := []struct {
		x, y, expected int
	}{
		{2, 3, 8},
		{2, 4, 16},
	}
	for _, ts := range cases {
		result := Pow(ts.x, ts.y)
		if result != ts.expected {
			t.Errorf("got %d expected %d", result, ts.expected)
		}
	}
}
```
Но есть проблема, если какой-то конкретный кейс упадет, мы не сможем узнать какой именно упал
![[Pasted image 20251002192016.png]]
Это могут пофиксить саб-тесты
### Саб-тесты
Саб-тесты позволяют запустить тест внутри теста. Благодаря этому можно будет понять какой именно тест упал. Но в слайс структур тогда нужно добавить еще поле с именем теста
```go
func TestPow(t *testing.T) {
	cases := []struct {
		x, y, expected int
		name           string
	}{
		{2, 3, 8, "First"},
		{2, 4, 20, "Second"},
	}
	for _, ts := range cases {
		t.Run(ts.name, func(t *testing.T) {
			result := Pow(ts.x, ts.y)
			if result != ts.expected {
				t.Errorf("got %d expected %d", result, ts.expected)
			}
		})
	}
}
```
![[Pasted image 20251002192200.png]]
### Параллелизация тестов
Есть такая метрика - Time To Market. Она говорит о том, через сколько решение будет в продакшене. Таких тестов как выше может быть тысячи (правда). Чтобы ускорить прогон тестов их нужно запускать параллельно
```go
func TestPow(t *testing.T) {
	t.Parallel()
	cases := []struct {
		x, y, expected int
		name           string
	}{
		{2, 3, 8, "First"},
		{2, 4, 16, "Second"},
	}
	for _, ts := range cases {
		t.Run(ts.name, func(t *testing.T) {
			t.Parallel()
			result := Pow(ts.x, ts.y)
			if result != ts.expected {
				t.Errorf("got %d expected %d", result, ts.expected)
			}
		})
	}
}
```
Верхний `t.Parallel` говорит о параллельном запуске относительно других тестов. А `t.Parallel` внутри саб-теста говорит о том, чтобы внутри теста запускать саб-тесты параллельно
### Test coverage
Степень покрытия теста в Go высчитывается цикломатически, то есть по количеству покрытых и не покрытых `if`. Посмотреть покрытие тестами
```shell
go test -cover
```
![[Pasted image 20251002193611.png]]
Но тут не понятно, что именно не покрыто. Все это дело можно вывеси в html
```shell
 go test -cover -coverprofile=coverage.out
 go tool cover -html=coverage.out  
```
И будет вот такая штука
![[Pasted image 20251002193727.png]]
Красным выделено то, что непокрыто. 